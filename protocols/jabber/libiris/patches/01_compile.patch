Index: src/irisnet/noncore/cutestuff/httppoll.cpp
===================================================================
--- src/irisnet/noncore/cutestuff/httppoll.cpp	(revision 1355305)
+++ src/irisnet/noncore/cutestuff/httppoll.cpp	(working copy)
@@ -584,10 +584,10 @@
 			s += QByteArray("Proxy-Authorization: Basic ") + str.toBase64() + "\r\n";
 		}
 		s += "Pragma: no-cache\r\n";
-		s += QByteArray("Host: ") + u.host() + "\r\n";
+		s += QByteArray("Host: ") + u.host().toUtf8() + "\r\n";
 	}
 	else {
-		s += QByteArray("Host: ") + d->host + "\r\n";
+		s += QByteArray("Host: ") + d->host.toUtf8() + "\r\n";
 	}
 	s += "Content-Type: application/x-www-form-urlencoded\r\n";
 	s += QByteArray("Content-Length: ") + QByteArray::number(d->postdata.size()) + "\r\n";
Index: src/jdns/jdns_p.h
===================================================================
--- src/jdns/jdns_p.h	(revision 1355305)
+++ src/jdns/jdns_p.h	(working copy)
@@ -58,7 +58,7 @@
 #include "jdns.h"
 #include "jdns_packet.h"
 
-// jdns_util.c
+/*  jdns_util.c */
 void *jdns_alloc(int size);
 void *jdns_realloc(void *p, int size);
 void jdns_free(void *p);
Index: src/jdns/jdns_mdnsd.c
===================================================================
--- src/jdns/jdns_mdnsd.c	(revision 1355305)
+++ src/jdns/jdns_mdnsd.c	(working copy)
@@ -38,18 +38,18 @@
 #define QTYPE_NS    JDNS_RTYPE_NS
 #define QTYPE_ANY   JDNS_RTYPE_ANY
 
-// size of query/publish hashes
+/*  size of query/publish hashes */
 #define SPRIME 108
-// size of cache hash
+/*  size of cache hash */
 #define LPRIME 1009
-// brute force garbage cleanup frequency, rarely needed (daily default)
+/*  brute force garbage cleanup frequency, rarely needed (daily default) */
 #define GC 86400
 
-// maximum number of items to cache.  if an attacker on the LAN advertises
-//   a million services, we don't want to crash our program trying to collect
-//   them all.  any dns records received beyond this max are ignored.  this
-//   means the attacker would succeed in DoS'ing the multicast dns network,
-//   but he wouldn't succeed in running our program out of memory.
+/*  maximum number of items to cache.  if an attacker on the LAN advertises */
+/*    a million services, we don't want to crash our program trying to collect */
+/*    them all.  any dns records received beyond this max are ignored.  this */
+/*    means the attacker would succeed in DoS'ing the multicast dns network, */
+/*    but he wouldn't succeed in running our program out of memory. */
 #define MAX_CACHE 16384
 
 #define bzero(p, size) memset(p, 0, size)
@@ -93,7 +93,7 @@
 struct mdnsdr_struct
 {
     struct mdnsda_struct rr;
-    char unique; // # of checks performed to ensure
+    char unique; /*  # of checks performed to ensure */
     int tries;
     void (*pubresult)(int, char *, int, void *);
     void *arg;
@@ -119,10 +119,10 @@
 
 void mygettimeofday(mdnsd d, struct mytimeval *tv)
 {
-    //struct timeval t;
-    //gettimeofday(&t, 0);
-    //tv->tv_sec = t.tv_sec;
-    //tv->tv_usec = t.tv_usec;
+    /* struct timeval t; */
+    /* gettimeofday(&t, 0); */
+    /* tv->tv_sec = t.tv_sec; */
+    /* tv->tv_usec = t.tv_usec; */
 
     int msec = d->cb_time_now(d, d->cb_arg);
     tv->tv_sec = msec / 1000;
@@ -161,7 +161,7 @@
     return (int)h;
 }
 
-// case-insensitive hash
+/*  case-insensitive hash */
 int _namehash_nocase(const char *s)
 {
     int n, len;
@@ -174,7 +174,7 @@
     return n;
 }
 
-// basic linked list and hash primitives
+/*  basic linked list and hash primitives */
 struct query *_q_next(mdnsd d, struct query *q, char *host, int type)
 {
     if(q == 0) q = d->queries[_namehash_nocase(host) % SPRIME];
@@ -250,7 +250,7 @@
     return 0;
 }
 
-// compare time values easily
+/*  compare time values easily */
 int _tvdiff(struct mytimeval old, struct mytimeval new)
 {
     int udiff = 0;
@@ -258,7 +258,7 @@
     return (new.tv_usec - old.tv_usec) + udiff;
 }
 
-// make sure not already on the list, then insert
+/*  make sure not already on the list, then insert */
 void _r_push(mdnsdr *list, mdnsdr r)
 {
     mdnsdr cur;
@@ -268,26 +268,26 @@
     *list = r;
 }
 
-// set this r to probing, set next probe time
+/*  set this r to probing, set next probe time */
 void _r_probe(mdnsd d, mdnsdr r)
 {
     (void)d;
     (void)r;
 }
 
-// force any r out right away, if valid
+/*  force any r out right away, if valid */
 void _r_publish(mdnsd d, mdnsdr r)
 {
-    if(r->unique && r->unique < 5) return; // probing already
+    if(r->unique && r->unique < 5) return; /*  probing already */
     r->tries = 0;
     d->publish.tv_sec = d->now.tv_sec; d->publish.tv_usec = d->now.tv_usec;
     _r_push(&d->a_publish,r);
 }
 
-// send r out asap
+/*  send r out asap */
 void _r_send(mdnsd d, mdnsdr r)
 {
-    // removing record
+    /*  removing record */
     if(r->rr.ttl == 0)
     {
         if(d->a_publish == r)
@@ -297,24 +297,24 @@
     }
 
     if(r->tries < 4)
-    { // being published, make sure that happens soon
+    { /*  being published, make sure that happens soon */
         d->publish.tv_sec = d->now.tv_sec; d->publish.tv_usec = d->now.tv_usec;
         return;
     }
     if(r->unique)
-    { // known unique ones can be sent asap
+    { /*  known unique ones can be sent asap */
         _r_push(&d->a_now,r);
         return;
     }
-    // set d->pause.tv_usec to random 20-120 msec
+    /*  set d->pause.tv_usec to random 20-120 msec */
     d->pause.tv_sec = d->now.tv_sec;
-    //d->pause.tv_usec = d->now.tv_usec + ((d->now.tv_usec % 100) + 20) * 1000;
+    /* d->pause.tv_usec = d->now.tv_usec + ((d->now.tv_usec % 100) + 20) * 1000; */
     d->pause.tv_usec = d->now.tv_usec;
     d->pause.tv_usec += ((d->cb_rand_int(d, d->cb_arg) % 100) + 20) * 1000;
     _r_push(&d->a_pause,r);
 }
 
-// create generic unicast response struct
+/*  create generic unicast response struct */
 void _u_push(mdnsd d, mdnsdr r, int id, const jdns_address_t *addr, unsigned short int port)
 {
     struct unicast *u;
@@ -348,7 +348,7 @@
 }
 
 void _q_done(mdnsd d, struct query *q)
-{ // no more query, update all it's cached entries, remove from lists
+{ /*  no more query, update all it's cached entries, remove from lists */
     struct cached *c = 0;
     struct query *cur;
     int i = _namehash_nocase(q->name) % SPRIME;
@@ -367,7 +367,7 @@
 }
 
 void _r_done(mdnsd d, mdnsdr r)
-{ // buh-bye, remove from hash and free
+{ /*  buh-bye, remove from hash and free */
     mdnsdr cur = 0;
     int i = _namehash_nocase((char *)r->rr.name) % SPRIME;
     if(d->a_now == r)
@@ -386,7 +386,7 @@
 }
 
 void _q_answer(mdnsd d, struct cached *c)
-{ // call the answer function with this cached entry
+{ /*  call the answer function with this cached entry */
     if(c->rr.ttl <= d->now.tv_sec) c->rr.ttl = 0;
     if(c->q->answer(&c->rr,c->q->arg) == -1) _q_done(d, c->q);
 }
@@ -404,7 +404,7 @@
 }
 
 void _c_expire(mdnsd d, struct cached **list)
-{ // expire any old entries in this list
+{ /*  expire any old entries in this list */
     struct cached *next, *cur = *list, *last = 0;
     while(cur != 0)
     {
@@ -412,7 +412,7 @@
         if(d->now.tv_sec >= cur->rr.ttl)
         {
             if(last) last->next = next;
-            if(*list == cur) *list = next; // update list pointer if the first one expired
+            if(*list == cur) *list = next; /*  update list pointer if the first one expired */
             --(d->cache_count);
             if(cur->q) _q_answer(d,cur);
             mdnsda_content_free(&cur->rr);
@@ -424,7 +424,7 @@
     }
 }
 
-// brute force expire any old cached records
+/*  brute force expire any old cached records */
 void _gc(mdnsd d)
 {
     int i;
@@ -453,18 +453,18 @@
     int i = _namehash_nocase((char *)r->owner) % LPRIME;
     struct cached *same_value;
 
-    // do we already have it?
-    //printf("cache: checking for entry: [%s] [%d]\n", r->owner, r->type);
+    /*  do we already have it? */
+    /* printf("cache: checking for entry: [%s] [%d]\n", r->owner, r->type); */
     same_value = _find_exact(d, r);
     if(same_value)
     {
-        //printf("already have entry of same value\n");
+        /* printf("already have entry of same value\n"); */
     }
 
     if(r->qclass == 32768 + d->class)
-    { // cache flush
-        // simulate removal of all records for this question,
-        //   except if the value hasn't changed
+    { /*  cache flush */
+        /*  simulate removal of all records for this question, */
+        /*    except if the value hasn't changed */
         c = 0;
         while((c = _c_next(d,c,(char *)r->owner,r->type)))
         {
@@ -473,12 +473,12 @@
         }
         _c_expire(d,&d->cache[i]);
 
-        // we may have expired same_value here, so check for it again
+        /*  we may have expired same_value here, so check for it again */
         same_value = _find_exact(d, r);
     }
 
     if(r->ttl == 0)
-    { // process deletes
+    { /*  process deletes */
         if(same_value)
             same_value->rr.ttl = 0;
         _c_expire(d,&d->cache[i]);
@@ -487,15 +487,15 @@
 
     if(same_value)
     {
-        //printf("updating ttl only\n");
+        /* printf("updating ttl only\n"); */
 
-        // only update ttl (this code directly copied from below)
+        /*  only update ttl (this code directly copied from below) */
         same_value->rr.ttl = d->now.tv_sec + (r->ttl / 2) + 8;
         same_value->rr.real_ttl = r->ttl;
         return;
     }
 
-    //printf("cache: inserting entry:    [%s] [%d]\n", r->owner, r->type);
+    /* printf("cache: inserting entry:    [%s] [%d]\n", r->owner, r->type); */
     if(d->cache_count >= MAX_CACHE)
         return;
 
@@ -503,7 +503,7 @@
     bzero(c,sizeof(struct cached));
     c->rr.name = (unsigned char *)jdns_strdup((char *)r->owner);
     c->rr.type = r->type;
-    c->rr.ttl = d->now.tv_sec + (r->ttl / 2) + 8; // XXX hack for now, BAD SPEC, start retrying just after half-waypoint, then expire
+    c->rr.ttl = d->now.tv_sec + (r->ttl / 2) + 8; /*  XXX hack for now, BAD SPEC, start retrying just after half-waypoint, then expire */
     c->rr.real_ttl = r->ttl;
     c->rr.rdlen = r->rdlength;
     c->rr.rdata = jdns_copy_array(r->rdata, r->rdlength);
@@ -530,11 +530,11 @@
         _q_answer(d,c);
     if(c->q && c->q->nexttry == 0)
     {
-        //printf("cache insert, but nexttry == 0\n");
+        /* printf("cache insert, but nexttry == 0\n"); */
         _q_reset(d,c->q);
         if(d->checkqlist == 0)
             d->checkqlist = c->q->nexttry;
-        //printf("after reset: q->nexttry=%d d->checkqlist=%d\n", c->q->nexttry, d->checkqlist);
+        /* printf("after reset: q->nexttry=%d d->checkqlist=%d\n", c->q->nexttry, d->checkqlist); */
     }
 }
 
@@ -623,8 +623,8 @@
 */
 
 int _r_out(mdnsd d, jdns_packet_t *m, mdnsdr *list)
-{ // copy a published record into an outgoing message
-    mdnsdr r; //, next;
+{ /*  copy a published record into an outgoing message */
+    mdnsdr r; /* , next; */
     unsigned short class;
     int ret = 0;
     while((r = *list) != 0)
@@ -641,7 +641,7 @@
 
 mdnsd mdnsd_new(int class, int frame, int port, int (*time_now)(mdnsd d, void *arg), int (*rand_int)(mdnsd d, void *arg), void *arg)
 {
-    //int i;
+    /* int i; */
     mdnsd d;
     d = (mdnsd)jdns_alloc(sizeof(struct mdnsd_struct));
     bzero(d,sizeof(struct mdnsd_struct));
@@ -658,7 +658,7 @@
 }
 
 void mdnsd_shutdown(mdnsd d)
-{ // shutting down, zero out ttl and push out all records
+{ /*  shutting down, zero out ttl and push out all records */
     int i;
     mdnsdr cur,next;
     d->a_now = 0;
@@ -676,10 +676,10 @@
 
 void mdnsd_flush(mdnsd d)
 {
-    // set all querys to 0 tries
-    // free whole cache
-    // set all mdnsdr to probing
-    // reset all answer lists
+    /*  set all querys to 0 tries */
+    /*  free whole cache */
+    /*  set all mdnsdr to probing */
+    /*  reset all answer lists */
 
     (void)d;
 }
@@ -688,8 +688,8 @@
 {
     int i;
 
-    // loop through all hashes, free everything
-    // free answers if any
+    /*  loop through all hashes, free everything */
+    /*  free answers if any */
 
     for(i = 0; i < LPRIME; ++i)
     {
@@ -745,27 +745,27 @@
     if(m->opts.qr == 0)
     {
         for(i=0;i<m->questions->count;i++)
-        { // process each query
+        { /*  process each query */
             jdns_packet_question_t *pq = (jdns_packet_question_t *)m->questions->item[i];
 
             if(pq->qclass != d->class || (r = _r_next(d,0,(char *)pq->qname->data,pq->qtype)) == 0) continue;
 
-            // send the matching unicast reply
+            /*  send the matching unicast reply */
             if(port != d->port) _u_push(d,r,m->id,addr,port);
 
             for(;r != 0; r = _r_next(d,r,(char *)pq->qname->data,pq->qtype))
-            { // check all of our potential answers
+            { /*  check all of our potential answers */
                 if(r->unique && r->unique < 5)
-                { // probing state, check for conflicts
+                { /*  probing state, check for conflicts */
                     for(j=0;j<resp->authorityCount;j++)
-                    { // check all to-be answers against our own
+                    { /*  check all to-be answers against our own */
                         jdns_rr_t *ns = resp->authorityRecords[j];
                         if(pq->qtype != ns->type || !jdns_domain_cmp(pq->qname->data, ns->owner)) continue;
                         if(!_a_match(ns,&r->rr))
                         {
-                            _conflict(d,r); // answer isn't ours, conflict!
+                            _conflict(d,r); /*  answer isn't ours, conflict! */
 
-                            // r is invalid after conflict, start all over
+                            /*  r is invalid after conflict, start all over */
                             r = 0;
                             break;
                         }
@@ -773,10 +773,10 @@
                     continue;
                 }
                 for(j=0;j<resp->answerCount;j++)
-                { // check the known answers for this question
+                { /*  check the known answers for this question */
                     jdns_rr_t *an = resp->answerRecords[j];
                     if(pq->qtype != an->type || !jdns_domain_cmp(pq->qname->data, an->owner)) continue;
-                    if(_a_match(an,&r->rr)) break; // they already have this answer
+                    if(_a_match(an,&r->rr)) break; /*  they already have this answer */
                 }
                 if(j == resp->answerCount) _r_send(d,r);
             }
@@ -785,13 +785,13 @@
     }
 
     for(i=0;i<resp->answerCount;i++)
-    { // process each answer, check for a conflict, and cache
+    { /*  process each answer, check for a conflict, and cache */
         jdns_rr_t *an = resp->answerRecords[i];
         if((r = _r_next(d,0,(char *)an->owner,an->type)) != 0 && r->unique && _a_match(an,&r->rr) == 0) _conflict(d,r);
         _cache(d,an);
     }
 
-    // cache additional records
+    /*  cache additional records */
     for(i=0;i<resp->additionalCount;i++)
     {
         jdns_rr_t *an = resp->additionalRecords[i];
@@ -806,22 +806,22 @@
     jdns_packet_t *m;
 
     mygettimeofday(d, &d->now);
-    //bzero(m,sizeof(struct message));
+    /* bzero(m,sizeof(struct message)); */
     m = jdns_packet_new();
 
-    // defaults, multicast
-    *port = 0; //htons(5353);
+    /*  defaults, multicast */
+    *port = 0; /* htons(5353); */
     *addr = 0;
-    // *ip = 0; //inet_addr("224.0.0.251");
+    /*  *ip = 0; //inet_addr("224.0.0.251"); */
     m->opts.qr = 1;
     m->opts.aa = 1;
 
     if(d->uanswers)
-    { // send out individual unicast answers
+    { /*  send out individual unicast answers */
         struct unicast *u = d->uanswers;
         d->uanswers = u->next;
         *port = u->port;
-        // *ip = u->to;
+        /*  *ip = u->to; */
         *addr = jdns_address_new();
         if(u->ipv6)
             jdns_address_set_ipv6(*addr, u->to6);
@@ -835,13 +835,13 @@
         goto end;
     }
 
-//printf("OUT: probing %X now %X pause %X publish %X\n",d->probing,d->a_now,d->a_pause,d->a_publish);
+/* printf("OUT: probing %X now %X pause %X publish %X\n",d->probing,d->a_now,d->a_pause,d->a_publish); */
 
-    // accumulate any immediate responses
+    /*  accumulate any immediate responses */
     if(d->a_now) { ret += _r_out(d, m, &d->a_now); }
 
     if(d->a_publish && _tvdiff(d->now,d->publish) <= 0)
-    { // check to see if it's time to send the publish retries (and unlink if done)
+    { /*  check to see if it's time to send the publish retries (and unlink if done) */
         mdnsdr next, cur = d->a_publish, last = 0;
         unsigned short class;
         while(cur /*&& message_packet_len(m) + _rr_len(&cur->rr) < d->frame*/ )
@@ -869,14 +869,14 @@
         }
     }
 
-    // if we're in shutdown, we're done
+    /*  if we're in shutdown, we're done */
     if(d->shutdown)
         goto end;
 
-    // check if a_pause is ready
+    /*  check if a_pause is ready */
     if(d->a_pause && _tvdiff(d->now, d->pause) <= 0) ret += _r_out(d, m, &d->a_pause);
 
-    // now process questions
+    /*  now process questions */
     if(ret)
         goto end;
     m->opts.qr = 0;
@@ -886,9 +886,9 @@
     {
         mdnsdr last = 0;
         for(r = d->probing; r != 0;)
-        { // scan probe list to ask questions and process published
+        { /*  scan probe list to ask questions and process published */
             if(r->unique == 4)
-            { // done probing, publish
+            { /*  done probing, publish */
                 mdnsdr next = r->list;
                 if(d->probing == r)
                     d->probing = r->list;
@@ -901,19 +901,19 @@
                 r = next;
                 continue;
             }
-            //message_qd(m, r->rr.name, r->rr.type, (unsigned short)d->class);
+            /* message_qd(m, r->rr.name, r->rr.type, (unsigned short)d->class); */
             _a_copyq(m->questions, r->rr.name, r->rr.type, (unsigned short)d->class);
             last = r;
             r = r->list;
         }
         for(r = d->probing; r != 0; last = r, r = r->list)
-        { // scan probe list again to append our to-be answers
+        { /*  scan probe list again to append our to-be answers */
             r->unique++;
             _a_copy(m->authorityRecords, r->rr.name, r->rr.type, (unsigned short)d->class, r->rr.ttl, &r->rr);
             ret++;
         }
         if(ret)
-        { // process probes again in the future
+        { /*  process probes again in the future */
             d->probe.tv_sec = d->now.tv_sec;
             d->probe.tv_usec = d->now.tv_usec + 250000;
             goto end;
@@ -921,24 +921,24 @@
     }
 
     if(d->checkqlist && d->now.tv_sec >= d->checkqlist)
-    { // process qlist for retries or expirations
+    { /*  process qlist for retries or expirations */
         struct query *q;
         struct cached *c;
         unsigned long int nextbest = 0;
 
-        // ask questions first, track nextbest time
+        /*  ask questions first, track nextbest time */
         for(q = d->qlist; q != 0; q = q->list)
             if(q->nexttry > 0 && q->nexttry <= d->now.tv_sec && q->tries < 3)
                 _a_copyq(m->questions, (unsigned char *)q->name, (unsigned short)q->type, (unsigned short)d->class);
             else if(q->nexttry > 0 && (nextbest == 0 || q->nexttry < nextbest))
                 nextbest = q->nexttry;
 
-        // include known answers, update questions
+        /*  include known answers, update questions */
         for(q = d->qlist; q != 0; q = q->list)
         {
             if(q->nexttry == 0 || q->nexttry > d->now.tv_sec) continue;
             if(q->tries == 3)
-            { // done retrying, expire and reset
+            { /*  done retrying, expire and reset */
                 _c_expire(d,&d->cache[_namehash_nocase(q->name) % LPRIME]);
                 _q_reset(d,q);
                 continue;
@@ -947,7 +947,7 @@
             q->nexttry = d->now.tv_sec + ++q->tries;
             if(nextbest == 0 || q->nexttry < nextbest)
                 nextbest = q->nexttry;
-            // if room, add all known good entries
+            /*  if room, add all known good entries */
             c = 0;
             while((c = _c_next(d,c,q->name,q->type)) != 0 && c->rr.ttl > d->now.tv_sec + 8 /* && message_packet_len(m) + _rr_len(&c->rr) < d->frame */)
             {
@@ -972,40 +972,40 @@
 struct mytimeval *mdnsd_sleep(mdnsd d)
 {
     int sec, usec;
-    //mdnsdr r;
+    /* mdnsdr r; */
     d->sleep.tv_sec = d->sleep.tv_usec = 0;
     #define RET while(d->sleep.tv_usec > 1000000) {d->sleep.tv_sec++;d->sleep.tv_usec -= 1000000;} return &d->sleep;
 
-    // first check for any immediate items to handle
+    /*  first check for any immediate items to handle */
     if(d->uanswers || d->a_now) return &d->sleep;
 
     mygettimeofday(d, &d->now);
 
     if(d->a_pause)
-    { // then check for paused answers
+    { /*  then check for paused answers */
         if((usec = _tvdiff(d->now,d->pause)) > 0) d->sleep.tv_usec = usec;
         RET;
     }
 
     if(d->probing)
-    { // now check for probe retries
+    { /*  now check for probe retries */
         if((usec = _tvdiff(d->now,d->probe)) > 0) d->sleep.tv_usec = usec;
         RET;
     }
 
     if(d->a_publish)
-    { // now check for publish retries
+    { /*  now check for publish retries */
         if((usec = _tvdiff(d->now,d->publish)) > 0) d->sleep.tv_usec = usec;
         RET;
     }
 
     if(d->checkqlist)
-    { // also check for queries with known answer expiration/retry
+    { /*  also check for queries with known answer expiration/retry */
         if((sec = d->checkqlist - d->now.tv_sec) > 0) d->sleep.tv_sec = sec;
         RET;
     }
 
-    // last resort, next gc expiration
+    /*  last resort, next gc expiration */
     if((sec = d->expireall - d->now.tv_sec) > 0) d->sleep.tv_sec = sec;
     RET;
 }
@@ -1029,15 +1029,15 @@
         q->arg = arg;
         while((cur = _c_next(d,cur,q->name,q->type)))
         {
-            cur->q = q; // any cached entries should be associated
-            _q_answer(d,cur); // and reported!
+            cur->q = q; /*  any cached entries should be associated */
+            _q_answer(d,cur); /*  and reported! */
         }
         _q_reset(d,q);
-        q->nexttry = d->checkqlist = d->now.tv_sec; // new questin, immediately send out
+        q->nexttry = d->checkqlist = d->now.tv_sec; /*  new questin, immediately send out */
 	return;
     }
     if(!answer)
-    { // no answer means we don't care anymore
+    { /*  no answer means we don't care anymore */
         _q_done(d,q);
         return;
     }
@@ -1081,7 +1081,7 @@
 {
     mdnsdr cur;
     if(r->unique && r->unique < 5)
-    { // probing yet, zap from that list first!
+    { /*  probing yet, zap from that list first! */
         if(d->probing == r) d->probing = r->list;
         else {
             for(cur=d->probing;cur->list != r;cur = cur->list);
Index: src/jdns/jdns_packet.c
===================================================================
--- src/jdns/jdns_packet.c	(revision 1355305)
+++ src/jdns/jdns_packet.c	(working copy)
@@ -25,15 +25,15 @@
 
 #include "jdns_p.h"
 
-// maximum length of a sublabel
+/*  maximum length of a sublabel */
 #define MAX_SUBLABEL_LENGTH  63
 
-// maximum length of a label, including final terminating zero (root sublabel)
-//   according to RFC 2181, the maximum length is 255, not counting the root
-//   sublabel.  so, with the root sublabel, that means a max length of 256.
+/*  maximum length of a label, including final terminating zero (root sublabel) */
+/*    according to RFC 2181, the maximum length is 255, not counting the root */
+/*    sublabel.  so, with the root sublabel, that means a max length of 256. */
 #define MAX_LABEL_LENGTH     256
 
-// jer's endian functions
+/*  jer's endian functions */
 static unsigned short int net2short(const unsigned char **bufp)
 {
 	unsigned short int i;
@@ -78,7 +78,7 @@
 	*bufp += 4;
 }
 
-// label stuff
+/*  label stuff */
 typedef struct jdns_packet_label
 {
 	JDNS_OBJECT
@@ -114,7 +114,7 @@
 	jdns_object_free(a);
 }
 
-// gets an offset for decompression.  does range and hop count checking also
+/*  gets an offset for decompression.  does range and hop count checking also */
 static int getoffset(const unsigned char *str, int refsize, int *hopsleft)
 {
 	unsigned short int x;
@@ -124,7 +124,7 @@
 	x = str[0] & 0x3f;
 	x <<= 8;
 	x |= str[1];
-	// stay in bounds
+	/*  stay in bounds */
 	if(x >= refsize)
 		return -1;
 	return x;
@@ -133,10 +133,10 @@
 static int readlabel(const unsigned char *in, int insize, const unsigned char *ref, int refsize, int *_at, jdns_string_t **name)
 {
 	int at;
-	// string format is one character smaller than dns format.  e.g.:
-	//   dns:    [7] affinix [3] com [0] = 13 bytes
-	//   string: "affinix.com."          = 12 bytes
-	// only exception is '.' itself, but that won't influence the max.
+	/*  string format is one character smaller than dns format.  e.g.: */
+	/*    dns:    [7] affinix [3] com [0] = 13 bytes */
+	/*    string: "affinix.com."          = 12 bytes */
+	/*  only exception is '.' itself, but that won't influence the max. */
 	unsigned char out[MAX_LABEL_LENGTH - 1];
 	int out_size;
 	const unsigned char *label, *last;
@@ -146,7 +146,7 @@
 
 	at = *_at;
 
-	// stay in range
+	/*  stay in range */
 	if(at < 0 || at >= insize)
 		return 0;
 
@@ -156,19 +156,19 @@
 	last = in + insize;
 	while(1)
 	{
-		// need a byte
+		/*  need a byte */
 		if(label + 1 > last)
 			goto error;
 
-		// we make this a while loop instead of an 'if', in case
-		//   there's a pointer to a pointer.  as a precaution,
-		//   we will hop no more than 8 times
+		/*  we make this a while loop instead of an 'if', in case */
+		/*    there's a pointer to a pointer.  as a precaution, */
+		/*    we will hop no more than 8 times */
 		hopsleft = 8;
 		while(*label & 0xc0)
 		{
 			int offset;
 
-			// need the next byte, too
+			/*  need the next byte, too */
 			if(label + 2 > last)
 				goto error;
 
@@ -184,14 +184,14 @@
 				last = ref + refsize;
 			}
 
-			// need a byte
+			/*  need a byte */
 			if(label + 1 > last)
 				goto error;
 		}
 
 		label_size = *label & 0x3f;
 
-		// null label?  then we're done
+		/*  null label?  then we're done */
 		if(label_size == 0)
 		{
 			if(!hopped_yet)
@@ -199,11 +199,11 @@
 			break;
 		}
 
-		// enough source bytes? (length byte + length)
+		/*  enough source bytes? (length byte + length) */
 		if(label + label_size + 1 > last)
 			goto error;
 
-		// enough dest bytes? (length + dot)
+		/*  enough dest bytes? (length + dot) */
 		if(out_size + label_size + 1 > MAX_LABEL_LENGTH - 1)
 			goto error;
 
@@ -227,20 +227,20 @@
 	return 0;
 }
 
-// this function compares labels in label format:
-//   [length] [value ...] [length] [value ...] [0]
+/*  this function compares labels in label format: */
+/*    [length] [value ...] [length] [value ...] [0] */
 static int matchlabel(const unsigned char *a, int asize, const unsigned char *b, int bsize, const unsigned char *ref, int refsize, int ahopsleft, int bhopsleft)
 {
 	int n, alen, blen, offset;
 
-	// same pointer?
+	/*  same pointer? */
 	if(a == b)
 		return 1;
 
 	if(asize < 1 || bsize < 1)
 		return 0;
 
-	// always ensure we get called without a pointer
+	/*  always ensure we get called without a pointer */
 	if(*a & 0xc0)
 	{
 		if(asize < 2)
@@ -263,28 +263,28 @@
 	alen = *a & 0x3f;
 	blen = *b & 0x3f;
 
-	// must be same length
+	/*  must be same length */
 	if(alen != blen)
 		return 0;
 
-	// done?
+	/*  done? */
 	if(alen == 0)
 		return 1;
 
-	// length byte + length + first byte of next label
+	/*  length byte + length + first byte of next label */
 	if(asize < alen + 2)
 		return 0;
 	if(bsize < blen + 2)
 		return 0;
 
-	// compare the value
+	/*  compare the value */
 	for(n = 1; n < alen + 1; ++n)
 	{
 		if(a[n] != b[n])
 			return 0;
 	}
 
-	// try next labels
+	/*  try next labels */
 	n = alen + 1;
 	return matchlabel(a + n, asize - n, b + n, bsize - n, ref, refsize, ahopsleft, bhopsleft);
 }
@@ -293,43 +293,43 @@
 {
 	int n, at, len;
 
-	// at least one byte, no larger than MAX_LABEL_LENGTH - 1 (one byte is
-	//   gained when converting to a label)
+	/*  at least one byte, no larger than MAX_LABEL_LENGTH - 1 (one byte is */
+	/*    gained when converting to a label) */
 	if(size < 1 || size > (MAX_LABEL_LENGTH - 1))
 		return 0;
 
-	// last byte must be a dot
+	/*  last byte must be a dot */
 	if(name[size - 1] != '.')
 		return 0;
 
-	// first byte can't be a dot if there are characters after
+	/*  first byte can't be a dot if there are characters after */
 	if(size > 1 && name[0] == '.')
 		return 0;
 
-	// each sublabel must be between 1 and MAX_SUBLABEL_LENGTH in length
+	/*  each sublabel must be between 1 and MAX_SUBLABEL_LENGTH in length */
 	at = 0;
 	while(1)
 	{
-		// search for dot or end
+		/*  search for dot or end */
 		for(n = at; n < size; ++n)
 		{
 			if(name[n] == '.')
 				break;
 		}
-		// length of last one is always zero
+		/*  length of last one is always zero */
 		if(n >= size)
 			break;
 
 		len = n - at;
 		if(len < 1 || len > MAX_SUBLABEL_LENGTH)
 			return 0;
-		at = n + 1; // skip over the dot
+		at = n + 1; /*  skip over the dot */
 	}
 
 	return 1;
 }
 
-// this function assumes label is pointing to a MAX_LABEL_LENGTH byte buffer
+/*  this function assumes label is pointing to a MAX_LABEL_LENGTH byte buffer */
 static int name_to_label(const jdns_string_t *name, unsigned char *label)
 {
 	int n, i, at, len;
@@ -347,29 +347,29 @@
 	i = 0;
 	while(1)
 	{
-		// search for dot or end
+		/*  search for dot or end */
 		for(n = at; n < name->size; ++n)
 		{
 			if(name->data[n] == '.')
 				break;
 		}
 		len = n - at;
-		if(i + (len + 1) > MAX_LABEL_LENGTH) // length byte + length
+		if(i + (len + 1) > MAX_LABEL_LENGTH) /*  length byte + length */
 			return 0;
 
 		label[i++] = len;
 		memcpy(label + i, name->data + at, len);
 		i += len;
 
-		if(n >= name->size) // end?
+		if(n >= name->size) /*  end? */
 			break;
-		at = n + 1; // skip over the dot
+		at = n + 1; /*  skip over the dot */
 	}
 
 	return i;
 }
 
-// lookup list is made of jdns_packet_labels
+/*  lookup list is made of jdns_packet_labels */
 static int writelabel(const jdns_string_t *name, int at, int left, unsigned char **bufp, jdns_list_t *lookup)
 {
 	unsigned char label[MAX_LABEL_LENGTH];
@@ -392,33 +392,33 @@
 
 			if(matchlabel(label + n, len - n, pl->value->data, pl->value->size, ref, refsize, 8, 8))
 			{
-				// set up a pointer right here, overwriting
-				//   the length byte and the first content
-				//   byte of this section within 'label'.
-				//   this is safe, because the length value
-				//   will always be greater than zero,
-				//   ensuring we have two bytes available to
-				//   use.
+				/*  set up a pointer right here, overwriting */
+				/*    the length byte and the first content */
+				/*    byte of this section within 'label'. */
+				/*    this is safe, because the length value */
+				/*    will always be greater than zero, */
+				/*    ensuring we have two bytes available to */
+				/*    use. */
 				l = label + n;
 				short2net((unsigned short int)pl->offset, &l);
 				label[n] |= 0xc0;
-				len = n + 2; // cut things short
+				len = n + 2; /*  cut things short */
 				break;
 			}
 		}
-		if(label[n] & 0xc0) // double loop, so break again
+		if(label[n] & 0xc0) /*  double loop, so break again */
 			break;
 	}
 
 	if(left < len)
 		return 0;
 
-	// copy into buffer, point there now
+	/*  copy into buffer, point there now */
 	memcpy(*bufp, label, len);
 	l = *bufp;
 	*bufp += len;
 
-	// for each new label, store its location for future compression
+	/*  for each new label, store its location for future compression */
 	for(n = 0; l[n]; n += l[n] + 1)
 	{
 		jdns_string_t *str;
@@ -437,9 +437,9 @@
 	return 1;
 }
 
-//----------------------------------------------------------------------------
-// jdns_packet_write
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_packet_write */
+/* ---------------------------------------------------------------------------- */
 #define JDNS_PACKET_WRITE_RAW  0
 #define JDNS_PACKET_WRITE_NAME 1
 
@@ -478,9 +478,9 @@
 	jdns_object_free(a);
 }
 
-//----------------------------------------------------------------------------
-// jdns_packet_question
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_packet_question */
+/* ---------------------------------------------------------------------------- */
 jdns_packet_question_t *jdns_packet_question_new()
 {
 	jdns_packet_question_t *a = JDNS_OBJECT_NEW(jdns_packet_question);
@@ -508,9 +508,9 @@
 	jdns_object_free(a);
 }
 
-//----------------------------------------------------------------------------
-// jdns_packet_resource
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_packet_resource */
+/* ---------------------------------------------------------------------------- */
 jdns_packet_resource_t *jdns_packet_resource_new()
 {
 	jdns_packet_resource_t *a = JDNS_OBJECT_NEW(jdns_packet_resource);
@@ -577,13 +577,13 @@
 	return readlabel(a->rdata, a->rdlength, p->raw_data, p->raw_size, at, name);
 }
 
-//----------------------------------------------------------------------------
-// jdns_packet
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_packet */
+/* ---------------------------------------------------------------------------- */
 
-// note: both process_qsection and process_rrsection modify the 'dest' list,
-//   even if later items cause an error.  this turns out to be convenient
-//   for handling truncated dns packets
+/*  note: both process_qsection and process_rrsection modify the 'dest' list, */
+/*    even if later items cause an error.  this turns out to be convenient */
+/*    for handling truncated dns packets */
 
 static int process_qsection(jdns_list_t *dest, int count, const unsigned char *data, int size, const unsigned char **bufp)
 {
@@ -605,7 +605,7 @@
 
 		offset += at;
 
-		// need 4 more bytes
+		/*  need 4 more bytes */
 		if(size - offset < 4)
 			goto error;
 
@@ -649,7 +649,7 @@
 
 		offset += at;
 
-		// need 10 more bytes
+		/*  need 10 more bytes */
 		if(offset + 10 > size)
 			goto error;
 
@@ -662,9 +662,9 @@
 		r->qclass = net2short(&buf);
 		r->ttl = net2long(&buf);
 
-		// per RFC 2181, ttl is supposed to be a 31 bit number.  if
-		//   the top bit of the 32 bit field is 1, then entire ttl is
-		//   to be considered 0.
+		/*  per RFC 2181, ttl is supposed to be a 31 bit number.  if */
+		/*    the top bit of the 32 bit field is 1, then entire ttl is */
+		/*    to be considered 0. */
 		if(r->ttl & 0x80000000)
 			r->ttl = 0;
 
@@ -672,7 +672,7 @@
 
 		offset = buf - data;
 
-		// make sure we have enough for the rdata
+		/*  make sure we have enough for the rdata */
 		if(size - offset < r->rdlength)
 		{
 			jdns_packet_resource_delete(r);
@@ -745,11 +745,11 @@
 		short2net(r->qclass, &buf);
 		long2net(r->ttl, &buf);
 
-		// skip over rdlength
+		/*  skip over rdlength */
 		rdlengthp = buf;
 		buf += 2;
 
-		// play write log
+		/*  play write log */
 		for(i = 0; i < r->writelog->count; ++i)
 		{
 			jdns_packet_write_t *write = (jdns_packet_write_t *)r->writelog->item[i];
@@ -761,14 +761,14 @@
 				memcpy(buf, write->value->data, write->value->size);
 				buf += write->value->size;
 			}
-			else // JDNS_PACKET_WRITE_NAME
+			else /*  JDNS_PACKET_WRITE_NAME */
 			{
 				if(!writelabel(write->value, buf - start, last - buf, &buf, lookup))
 					goto error;
 			}
 		}
 
-		i = buf - rdlengthp; // should be rdata size + 2
+		i = buf - rdlengthp; /*  should be rdata size + 2 */
 		short2net((unsigned short int)(i - 2), &rdlengthp);
 	}
 
@@ -857,44 +857,44 @@
 	jdns_packet_t *tmp = 0;
 	const unsigned char *buf;
 
-	// need at least some data
+	/*  need at least some data */
 	if(!data || size == 0)
 		return 0;
 
-	// header (id + options + item counts) is 12 bytes
+	/*  header (id + options + item counts) is 12 bytes */
 	if(size < 12)
 		goto error;
 
 	tmp = jdns_packet_new();
 	buf = data;
 
-	// id
+	/*  id */
 	tmp->id = net2short(&buf);
 
-	// options
-	if(buf[0] & 0x80)                        // qr is bit 7
+	/*  options */
+	if(buf[0] & 0x80)                        /*  qr is bit 7 */
 		tmp->opts.qr = 1;
-	tmp->opts.opcode = (buf[0] & 0x78) >> 3; // opcode is bits 6,5,4,3
-	if(buf[0] & 0x04)                        // aa is bit 2
+	tmp->opts.opcode = (buf[0] & 0x78) >> 3; /*  opcode is bits 6,5,4,3 */
+	if(buf[0] & 0x04)                        /*  aa is bit 2 */
 		tmp->opts.aa = 1;
-	if(buf[0] & 0x02)                        // tc is bit 1
+	if(buf[0] & 0x02)                        /*  tc is bit 1 */
 		tmp->opts.tc = 1;
-	if(buf[0] & 0x01)                        // rd is bit 0
+	if(buf[0] & 0x01)                        /*  rd is bit 0 */
 		tmp->opts.rd = 1;
-	if(buf[1] & 0x80)                        // ra is bit 7 (second byte)
+	if(buf[1] & 0x80)                        /*  ra is bit 7 (second byte) */
 		tmp->opts.ra = 1;
-	tmp->opts.z = (buf[1] & 0x70) >> 4;      // z is bits 6,5,4
-	tmp->opts.rcode = buf[1] & 0x0f;         // rcode is bits 3,2,1,0
+	tmp->opts.z = (buf[1] & 0x70) >> 4;      /*  z is bits 6,5,4 */
+	tmp->opts.rcode = buf[1] & 0x0f;         /*  rcode is bits 3,2,1,0 */
 	buf += 2;
 
-	// item counts
+	/*  item counts */
 	tmp->qdcount = net2short(&buf);
 	tmp->ancount = net2short(&buf);
 	tmp->nscount = net2short(&buf);
 	tmp->arcount = net2short(&buf);
 
-	// if these fail, we don't count them as errors, since the packet
-	//   might have been truncated
+	/*  if these fail, we don't count them as errors, since the packet */
+	/*    might have been truncated */
 	if(!process_qsection(tmp->questions, tmp->qdcount, data, size, &buf))
 		goto skip;
 	if(!process_rrsection(tmp->answerRecords, tmp->ancount, data, size, &buf))
@@ -907,7 +907,7 @@
 	tmp->fully_parsed = 1;
 
 skip:
-	// keep the raw data for reference during rdata parsing
+	/*  keep the raw data for reference during rdata parsing */
 	tmp->raw_size = size;
 	tmp->raw_data = jdns_copy_array(data, size);
 
@@ -925,9 +925,9 @@
 	unsigned char *buf, *last;
 	unsigned char c;
 	int size;
-	jdns_list_t *lookup = 0; // to hold jdns_packet_label_t
+	jdns_list_t *lookup = 0; /*  to hold jdns_packet_label_t */
 
-	// clear out any existing raw data before we begin
+	/*  clear out any existing raw data before we begin */
 	if(a->raw_data)
 	{
 		jdns_free(a->raw_data);
@@ -935,7 +935,7 @@
 		a->raw_size = 0;
 	}
 
-	// preallocate
+	/*  preallocate */
 	size = maxsize;
 	block = (unsigned char *)jdns_alloc(size);
 	memset(block, 0, size);
@@ -969,7 +969,7 @@
 	short2net((unsigned short int)a->authorityRecords->count, &buf);
 	short2net((unsigned short int)a->additionalRecords->count, &buf);
 
-	// append sections
+	/*  append sections */
 	lookup = jdns_list_new();
 	lookup->autoDelete = 1;
 
@@ -982,14 +982,14 @@
 	if(!append_rrsection(a->additionalRecords, buf - block, last - buf, &buf, lookup))
 		goto error;
 
-	// done with all sections
+	/*  done with all sections */
 	jdns_list_delete(lookup);
 
-	// condense
+	/*  condense */
 	size = buf - block;
 	block = (unsigned char *)jdns_realloc(block, size);
 
-	// finalize
+	/*  finalize */
 	a->qdcount = a->questions->count;
 	a->ancount = a->answerRecords->count;
 	a->nscount = a->authorityRecords->count;
Index: src/jdns/jdns_mdnsd.h
===================================================================
--- src/jdns/jdns_mdnsd.h	(revision 1355305)
+++ src/jdns/jdns_mdnsd.h	(working copy)
@@ -33,9 +33,9 @@
 	unsigned long int tv_usec;  /* microseconds */
 };
 
-typedef struct mdnsd_struct *mdnsd; // main daemon data
-typedef struct mdnsdr_struct *mdnsdr; // record entry
-// answer data
+typedef struct mdnsd_struct *mdnsd; /*  main daemon data */
+typedef struct mdnsdr_struct *mdnsdr; /*  record entry */
+/*  answer data */
 typedef struct mdnsda_struct
 {
     unsigned char *name;
@@ -44,77 +44,77 @@
     unsigned long int real_ttl;
     unsigned short int rdlen;
     unsigned char *rdata;
-    unsigned long int ip; // A
-    unsigned char *rdname; // NS/CNAME/PTR/SRV
-    struct { unsigned short int priority, weight, port; } srv; // SRV
+    unsigned long int ip; /*  A */
+    unsigned char *rdname; /*  NS/CNAME/PTR/SRV */
+    struct { unsigned short int priority, weight, port; } srv; /*  SRV */
 } *mdnsda;
 
-///////////
-// Global functions
-//
-// create a new mdns daemon for the given class of names (usually 1) and maximum frame size
+/* ///////// */
+/*  Global functions */
+/*  */
+/*  create a new mdns daemon for the given class of names (usually 1) and maximum frame size */
 mdnsd mdnsd_new(int class, int frame, int port, int (*time_now)(mdnsd d, void *arg), int (*rand_int)(mdnsd d, void *arg), void *arg);
-//
-// gracefully shutdown the daemon, use mdnsd_out() to get the last packets
+/*  */
+/*  gracefully shutdown the daemon, use mdnsd_out() to get the last packets */
 void mdnsd_shutdown(mdnsd d);
-//
-// flush all cached records (network/interface changed)
+/*  */
+/*  flush all cached records (network/interface changed) */
 void mdnsd_flush(mdnsd d);
-//
-// free given mdnsd (should have used mdnsd_shutdown() first!)
+/*  */
+/*  free given mdnsd (should have used mdnsd_shutdown() first!) */
 void mdnsd_free(mdnsd d);
-//
-///////////
+/*  */
+/* ///////// */
 
-///////////
-// I/O functions
-//
-// incoming message from host (to be cached/processed)
+/* ///////// */
+/*  I/O functions */
+/*  */
+/*  incoming message from host (to be cached/processed) */
 void mdnsd_in(mdnsd d, const jdns_packet_t *m, const jdns_response_t *resp, const jdns_address_t *addr, unsigned short int port);
-//
-// outgoing messge to be delivered to host, returns >0 if one was returned and m/ip/port set
+/*  */
+/*  outgoing messge to be delivered to host, returns >0 if one was returned and m/ip/port set */
 int mdnsd_out(mdnsd d, jdns_packet_t **m, jdns_address_t **addr, unsigned short int *port);
-//
-// returns the max wait-time until mdnsd_out() needs to be called again 
+/*  */
+/*  returns the max wait-time until mdnsd_out() needs to be called again  */
 struct mytimeval *mdnsd_sleep(mdnsd d);
-//
-////////////
+/*  */
+/* ////////// */
 
-///////////
-// Q/A functions
-// 
-// register a new query
-//   answer(record, arg) is called whenever one is found/changes/expires (immediate or anytime after, mdnsda valid until ->ttl==0)
-//   either answer returns -1, or another mdnsd_query with a NULL answer will remove/unregister this query
+/* ///////// */
+/*  Q/A functions */
+/*   */
+/*  register a new query */
+/*    answer(record, arg) is called whenever one is found/changes/expires (immediate or anytime after, mdnsda valid until ->ttl==0) */
+/*    either answer returns -1, or another mdnsd_query with a NULL answer will remove/unregister this query */
 void mdnsd_query(mdnsd d, char *host, int type, int (*answer)(mdnsda a, void *arg), void *arg);
-//
-// returns the first (if last == NULL) or next answer after last from the cache
-//   mdnsda only valid until an I/O function is called
+/*  */
+/*  returns the first (if last == NULL) or next answer after last from the cache */
+/*    mdnsda only valid until an I/O function is called */
 mdnsda mdnsd_list(mdnsd d, char *host, int type, mdnsda last);
-//
-///////////
+/*  */
+/* ///////// */
 
-///////////
-// Publishing functions
-//
-// create a new unique record (try mdnsda_list first to make sure it's not used)
-//   conflict(arg) called at any point when one is detected and unable to recover
-//   after the first data is set_*(), any future changes effectively expire the old one and attempt to create a new unique record
+/* ///////// */
+/*  Publishing functions */
+/*  */
+/*  create a new unique record (try mdnsda_list first to make sure it's not used) */
+/*    conflict(arg) called at any point when one is detected and unable to recover */
+/*    after the first data is set_*(), any future changes effectively expire the old one and attempt to create a new unique record */
 mdnsdr mdnsd_unique(mdnsd d, char *host, int type, long int ttl, void (*pubresult)(int result, char *host, int type, void *arg), void *arg);
-// 
-// create a new shared record
+/*   */
+/*  create a new shared record */
 mdnsdr mdnsd_shared(mdnsd d, char *host, int type, long int ttl);
-//
-// de-list the given record
+/*  */
+/*  de-list the given record */
 void mdnsd_done(mdnsd d, mdnsdr r);
-//
-// these all set/update the data for the given record, nothing is published until they are called
+/*  */
+/*  these all set/update the data for the given record, nothing is published until they are called */
 void mdnsd_set_raw(mdnsd d, mdnsdr r, char *data, int len);
 void mdnsd_set_host(mdnsd d, mdnsdr r, char *name);
 void mdnsd_set_ip(mdnsd d, mdnsdr r, unsigned long int ip);
 void mdnsd_set_srv(mdnsd d, mdnsdr r, int priority, int weight, int port, char *name);
-//
-///////////
+/*  */
+/* ///////// */
 
 
 #endif
Index: src/jdns/jdns_packet.h
===================================================================
--- src/jdns/jdns_packet.h	(revision 1355305)
+++ src/jdns/jdns_packet.h	(working copy)
@@ -26,22 +26,22 @@
 
 #include "jdns.h"
 
-// -- howto --
-//
-// writing packets:
-//   1) call jdns_packet_new()
-//   2) populate the jdns_packet_t structure, using the functions
-//      as necessary
-//   3) call jdns_packet_export() to populate the raw data of the packet
-//
-// reading packets:
-//   1) call jdns_packet_new()
-//   2) call jdns_packet_import() with the raw data
-//   3) the jdns_packet_t structure is now populated
-//
-// IMPORTANT: all names must be valid. that is, ending in a dot character
+/*  -- howto -- */
+/*  */
+/*  writing packets: */
+/*    1) call jdns_packet_new() */
+/*    2) populate the jdns_packet_t structure, using the functions */
+/*       as necessary */
+/*    3) call jdns_packet_export() to populate the raw data of the packet */
+/*  */
+/*  reading packets: */
+/*    1) call jdns_packet_new() */
+/*    2) call jdns_packet_import() with the raw data */
+/*    3) the jdns_packet_t structure is now populated */
+/*  */
+/*  IMPORTANT: all names must be valid. that is, ending in a dot character */
 
-int jdns_packet_name_isvalid(const unsigned char *name, int size); // 0 if not valid
+int jdns_packet_name_isvalid(const unsigned char *name, int size); /*  0 if not valid */
 
 typedef struct jdns_packet_question
 {
@@ -62,12 +62,12 @@
 	JDNS_OBJECT
 	jdns_string_t *qname;
 	unsigned short int qtype, qclass;
-	unsigned long int ttl; // 31-bit number, top bit always 0
+	unsigned long int ttl; /*  31-bit number, top bit always 0 */
 	unsigned short int rdlength;
 	unsigned char *rdata;
 
-	// private
-	jdns_list_t *writelog; // jdns_packet_write_t
+	/*  private */
+	jdns_list_t *writelog; /*  jdns_packet_write_t */
 } jdns_packet_resource_t;
 
 jdns_packet_resource_t *jdns_packet_resource_new();
@@ -86,21 +86,21 @@
 		unsigned short qr, opcode, aa, tc, rd, ra, z, rcode;
 	} opts;
 
-	// item counts as specified by the packet.  do not use these
-	//   for iteration over the item lists, since they can be wrong
-	//   if the packet is truncated.
+	/*  item counts as specified by the packet.  do not use these */
+	/*    for iteration over the item lists, since they can be wrong */
+	/*    if the packet is truncated. */
 	int qdcount, ancount, nscount, arcount;
 
-	// value lists
-	jdns_list_t *questions;         // jdns_packet_question_t
-	jdns_list_t *answerRecords;     // jdns_packet_resource_t
-	jdns_list_t *authorityRecords;  // jdns_packet_resource_t
-	jdns_list_t *additionalRecords; // jdns_packet_resource_t
+	/*  value lists */
+	jdns_list_t *questions;         /*  jdns_packet_question_t */
+	jdns_list_t *answerRecords;     /*  jdns_packet_resource_t */
+	jdns_list_t *authorityRecords;  /*  jdns_packet_resource_t */
+	jdns_list_t *additionalRecords; /*  jdns_packet_resource_t */
 
-	// since dns packets are allowed to be truncated, it is possible
-	//   for a packet to not get fully parsed yet still be considered
-	//   successfully parsed.  this flag means the packet was fully
-	//   parsed also.
+	/*  since dns packets are allowed to be truncated, it is possible */
+	/*    for a packet to not get fully parsed yet still be considered */
+	/*    successfully parsed.  this flag means the packet was fully */
+	/*    parsed also. */
 	int fully_parsed;
 
 	int raw_size;
@@ -110,7 +110,7 @@
 jdns_packet_t *jdns_packet_new();
 jdns_packet_t *jdns_packet_copy(const jdns_packet_t *a);
 void jdns_packet_delete(jdns_packet_t *a);
-int jdns_packet_import(jdns_packet_t **a, const unsigned char *data, int size); // 0 on fail
-int jdns_packet_export(jdns_packet_t *a, int maxsize); // 0 on fail
+int jdns_packet_import(jdns_packet_t **a, const unsigned char *data, int size); /*  0 on fail */
+int jdns_packet_export(jdns_packet_t *a, int maxsize); /*  0 on fail */
 
 #endif
Index: src/jdns/jdns_util.c
===================================================================
--- src/jdns/jdns_util.c	(revision 1355305)
+++ src/jdns/jdns_util.c	(working copy)
@@ -25,9 +25,9 @@
 
 #include "jdns_packet.h"
 
-//----------------------------------------------------------------------------
-// misc
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  misc */
+/* ---------------------------------------------------------------------------- */
 void *jdns_alloc(int size)
 {
 	return malloc(size);
@@ -48,7 +48,7 @@
 	char *p;
 	int len;
 
-	len = strlen(s) + 1; // the zero
+	len = strlen(s) + 1; /*  the zero */
 	p = (char *)jdns_alloc(len);
 	memcpy(p, s, len);
 	return p;
@@ -69,7 +69,7 @@
 	int n;
 	int len_a;
 
-	// case-insensitive compare
+	/*  case-insensitive compare */
 	len_a = _ustrlen(a);
 	if(len_a != (int)_ustrlen(b))
 		return 0;
@@ -135,7 +135,7 @@
 	}
 	out = jdns_string_new();
 	out->size = sizei - 1;
-	out->data = dest; // must be zero-terminated, which it is
+	out->data = dest; /*  must be zero-terminated, which it is */
 	return out;
 #else
 	jdns_string_t *out;
@@ -153,7 +153,7 @@
 {
 #if defined(_MSC_VER) && _MSC_VER >= 1400
 	int len;
-	// deliberately unsafe
+	/*  deliberately unsafe */
 	len = strlen(src);
 	if(strcpy_s(dst, len + 1, src) != 0)
 		return 0;
@@ -163,9 +163,9 @@
 #endif
 }
 
-//----------------------------------------------------------------------------
-// jdns_object
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_object */
+/* ---------------------------------------------------------------------------- */
 void *jdns_object_new(int size, void (*dtor)(void *), void *(*cctor)(const void *))
 {
 	jdns_object_t *a = (jdns_object_t *)jdns_alloc(size);
@@ -190,9 +190,9 @@
 	jdns_free(a);
 }
 
-//----------------------------------------------------------------------------
-// jdns_list
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_list */
+/* ---------------------------------------------------------------------------- */
 jdns_list_t *jdns_list_new()
 {
 	jdns_list_t *a = JDNS_OBJECT_NEW(jdns_list);
@@ -207,14 +207,14 @@
 {
 	jdns_list_t *c = jdns_list_new();
 
-	// note: copying a list with autoDelete should not ever be done.
-	//   heck, let's not even allow it.  return an empty list.
+	/*  note: copying a list with autoDelete should not ever be done. */
+	/*    heck, let's not even allow it.  return an empty list. */
 	if(a->autoDelete)
 		return c;
 
 	c->valueList = a->valueList;
 
-	// copy the items
+	/*  copy the items */
 	if(a->item)
 	{
 		int n;
@@ -222,13 +222,13 @@
 		c->item = (void **)jdns_alloc(sizeof(void *) * c->count);
 		if(a->valueList)
 		{
-			// deep copy
+			/*  deep copy */
 			for(n = 0; n < c->count; ++n)
 				c->item[n] = jdns_object_copy(a->item[n]);
 		}
 		else
 		{
-			// just the pointer
+			/*  just the pointer */
 			for(n = 0; n < c->count; ++n)
 				c->item[n] = a->item[n];
 		}
@@ -248,7 +248,7 @@
 {
 	if(a->item)
 	{
-		// delete the items if necessary
+		/*  delete the items if necessary */
 		if(a->valueList || a->autoDelete)
 		{
 			int n;
@@ -263,19 +263,19 @@
 
 void jdns_list_insert(jdns_list_t *a, void *item, int pos)
 {
-	// make memory
+	/*  make memory */
 	if(!a->item)
 		a->item = (void **)jdns_alloc(sizeof(void *));
 	else
 		a->item = (void **)jdns_realloc(a->item, sizeof(void *) * (a->count + 1));
 
-	// prepare position
+	/*  prepare position */
 	if(pos != -1)
 		memmove(a->item + pos + 1, a->item + pos, (a->count - pos) * sizeof(void *));
 	else
 		pos = a->count;
 
-	// insert it
+	/*  insert it */
 	if(a->valueList)
 		a->item[pos] = jdns_object_copy(item);
 	else
@@ -311,11 +311,11 @@
 	if(pos < 0 || pos >= a->count)
 		return;
 
-	// delete the item if necessary
+	/*  delete the item if necessary */
 	if(a->valueList || a->autoDelete)
 		jdns_object_delete(a->item[pos]);
 
-	// free the position
+	/*  free the position */
 	if(a->count > 1)
 	{
 		memmove(a->item + pos, a->item + pos + 1, (a->count - pos - 1) * sizeof(void *));
@@ -329,9 +329,9 @@
 	}
 }
 
-//----------------------------------------------------------------------------
-// jdns_string
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_string */
+/* ---------------------------------------------------------------------------- */
 jdns_string_t *jdns_string_new()
 {
 	jdns_string_t *s = JDNS_OBJECT_NEW(jdns_string);
@@ -397,21 +397,21 @@
 		if(n == -1)
 			n = s->size;
 		len = n - at;
-		// FIXME: should we allow empty items?
-		//if(len == 0)
-		//	break;
+		/*  FIXME: should we allow empty items? */
+		/* if(len == 0) */
+		/* 	break; */
 		str = jdns_string_new();
 		jdns_string_set(str, s->data + at, len);
 		jdns_stringlist_append(out, str);
 		jdns_string_delete(str);
-		at = n + 1; // skip over separator
+		at = n + 1; /*  skip over separator */
 	}
 	return out;
 }
 
-//----------------------------------------------------------------------------
-// jdns_stringlist
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_stringlist */
+/* ---------------------------------------------------------------------------- */
 jdns_stringlist_t *jdns_stringlist_new()
 {
 	jdns_list_t *a = jdns_list_new();
@@ -427,7 +427,7 @@
 void jdns_stringlist_delete(jdns_stringlist_t *a)
 {
 	jdns_list_delete((jdns_list_t *)a);
-	// note: no need to call jdns_object_free() here
+	/*  note: no need to call jdns_object_free() here */
 }
 
 void jdns_stringlist_append(jdns_stringlist_t *a, const jdns_string_t *str)
@@ -435,9 +435,9 @@
 	jdns_list_insert_value((jdns_list_t *)a, str, -1);
 }
 
-//----------------------------------------------------------------------------
-// jdns_address
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_address */
+/* ---------------------------------------------------------------------------- */
 jdns_address_t *jdns_address_new()
 {
 	jdns_address_t *a = alloc_type(jdns_address_t);
@@ -474,7 +474,7 @@
 	jdns_free(a->c_str);
 	a->isIpv6 = 0;
 	a->addr.v4 = ipv4;
-	a->c_str = (char *)jdns_alloc(16); // max size (3 * 4 + 3 + 1)
+	a->c_str = (char *)jdns_alloc(16); /*  max size (3 * 4 + 3 + 1) */
 	jdns_sprintf_s(a->c_str, 16, "%d.%d.%d.%d",
 		(unsigned char)((ipv4 >> 24) & 0xff),
 		(unsigned char)((ipv4 >> 16) & 0xff),
@@ -494,8 +494,8 @@
 	a->addr.v6 = (unsigned char *)jdns_alloc(16);
 	memcpy(a->addr.v6, ipv6, 16);
 	p = (unsigned char *)a->addr.v6;
-	a->c_str = (char *)jdns_alloc(40); // max size (8 * 4 + 7 + 1)
-	// each word in a 16-byte ipv6 address is network byte order
+	a->c_str = (char *)jdns_alloc(40); /*  max size (8 * 4 + 7 + 1) */
+	/*  each word in a 16-byte ipv6 address is network byte order */
 	for(n = 0; n < 8; ++n)
 		word[n] = ((unsigned short)(p[n * 2]) << 8) + (unsigned short)(p[n * 2 + 1]);
 	jdns_sprintf_s(a->c_str, 40, "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X", word[0], word[1], word[2], word[3], word[4], word[5], word[6], word[7]);
@@ -505,7 +505,7 @@
 {
 	int slen = strlen(str);
 
-	// ipv6
+	/*  ipv6 */
 	if(strchr(str, ':'))
 	{
 		jdns_string_t *in;
@@ -518,7 +518,7 @@
 		list = jdns_string_split(in, ':');
 		jdns_string_delete(in);
 
-		// a confusing outputting-backwards parser adapted from qt
+		/*  a confusing outputting-backwards parser adapted from qt */
 
 		count = list->count;
 
@@ -622,7 +622,7 @@
 				p2 = str + slen;
 			len = p2 - p;
 
-			// convert the section into a byte
+			/*  convert the section into a byte */
 			part = (char *)jdns_alloc(len + 1);
 			memcpy(part, p, len);
 			part[len] = 0;
@@ -632,11 +632,11 @@
 				break;
 			b[at++] = (unsigned char)x;
 
-			// done?
+			/*  done? */
 			if(p2 >= str + slen)
 				break;
 
-			// skip over the separator
+			/*  skip over the separator */
 			p = p2 + 1;
 		}
 		if(at != 4)
@@ -660,7 +660,7 @@
 
 int jdns_address_cmp(const jdns_address_t *a, const jdns_address_t *b)
 {
-	// same protocol?
+	/*  same protocol? */
 	if(a->isIpv6 != b->isIpv6)
 		return 0;
 	if(a->isIpv6)
@@ -682,7 +682,7 @@
 	return 0;
 }
 
-// FF02::FB
+/*  FF02::FB */
 unsigned char jdns_multicast_addr6_value_v6[] =
 {
 	0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -703,9 +703,9 @@
 	return a;
 }
 
-//----------------------------------------------------------------------------
-// jdns_server
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_server */
+/* ---------------------------------------------------------------------------- */
 jdns_server_t *jdns_server_new()
 {
 	jdns_server_t *s = alloc_type(jdns_server_t);
@@ -743,9 +743,9 @@
 	s->name = _ustrdup(name);
 }
 
-//----------------------------------------------------------------------------
-// jdns_nameserver
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_nameserver */
+/* ---------------------------------------------------------------------------- */
 jdns_nameserver_t *jdns_nameserver_new()
 {
 	jdns_nameserver_t *a = alloc_type(jdns_nameserver_t);
@@ -779,9 +779,9 @@
 	a->port = port;
 }
 
-//----------------------------------------------------------------------------
-// jdns_nameserverlist
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_nameserverlist */
+/* ---------------------------------------------------------------------------- */
 jdns_nameserverlist_t *jdns_nameserverlist_new()
 {
 	jdns_nameserverlist_t *a = alloc_type(jdns_nameserverlist_t);
@@ -829,9 +829,9 @@
 	++a->count;
 }
 
-//----------------------------------------------------------------------------
-// jdns_dnshost
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_dnshost */
+/* ---------------------------------------------------------------------------- */
 jdns_dnshost_t *jdns_dnshost_new()
 {
 	jdns_dnshost_t *a = alloc_type(jdns_dnshost_t);
@@ -859,9 +859,9 @@
 	jdns_free(a);
 }
 
-//----------------------------------------------------------------------------
-// jdns_dnshostlist
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_dnshostlist */
+/* ---------------------------------------------------------------------------- */
 jdns_dnshostlist_t *jdns_dnshostlist_new()
 {
 	jdns_dnshostlist_t *a = alloc_type(jdns_dnshostlist_t);
@@ -908,9 +908,9 @@
 	++a->count;
 }
 
-//----------------------------------------------------------------------------
-// jdns_dnsparams
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_dnsparams */
+/* ---------------------------------------------------------------------------- */
 jdns_dnsparams_t *jdns_dnsparams_new()
 {
 	jdns_dnsparams_t *a = alloc_type(jdns_dnsparams_t);
@@ -958,9 +958,9 @@
 	jdns_dnshost_delete(h);
 }
 
-//----------------------------------------------------------------------------
-// jdns_rr
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_rr */
+/* ---------------------------------------------------------------------------- */
 void _jdns_rr_data_reset(jdns_rr_t *r)
 {
 	if(r->rdata)
@@ -1184,7 +1184,7 @@
 		case JDNS_RTYPE_MX:
 		case JDNS_RTYPE_SRV:
 		{
-			// consider it valid if we don't have a known to check
+			/*  consider it valid if we don't have a known to check */
 			if(!r->haveKnown)
 				return 1;
 			if(!jdns_packet_name_isvalid(r->data.server->name, _ustrlen(r->data.server->name)))
@@ -1260,9 +1260,9 @@
 	return out;
 }
 
-// if the type is known, then it must be parsed properly
-// if the type is unknown, then that's ok
-// rdata is always copied, known or not
+/*  if the type is known, then it must be parsed properly */
+/*  if the type is unknown, then that's ok */
+/*  rdata is always copied, known or not */
 jdns_rr_t *jdns_rr_from_resource(const jdns_packet_resource_t *pr, const jdns_packet_t *ref)
 {
 	jdns_rr_t *rr = 0;
@@ -1435,7 +1435,7 @@
 	{
 		rr->qclass = pr->qclass;
 		rr->owner = _ustrdup(pr->qname->data);
-		rr->ttl = (int)pr->ttl; // pr->ttl is 31-bits, cast is safe
+		rr->ttl = (int)pr->ttl; /*  pr->ttl is 31-bits, cast is safe */
 		rr->rdlength = pr->rdlength;
 		rr->rdata = jdns_copy_array(pr->rdata, pr->rdlength);
 	}
@@ -1443,9 +1443,9 @@
 	return rr;
 }
 
-//----------------------------------------------------------------------------
-// jdns_response
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_response */
+/* ---------------------------------------------------------------------------- */
 #define ARRAY_DELETE(array, count, dtor) \
 	{ \
 		if(count > 0) \
@@ -1538,7 +1538,7 @@
 	jdns_rr_t *rr = r->answerRecords[pos];
 	jdns_rr_delete(rr);
 
-	// free the position
+	/*  free the position */
 	if(r->answerCount > 1)
 	{
 		memmove(r->answerRecords + pos, r->answerRecords + pos + 1, (r->answerCount - pos - 1) * sizeof(void *));
Index: src/jdns/jdns_sys.c
===================================================================
--- src/jdns/jdns_sys.c	(revision 1355305)
+++ src/jdns/jdns_sys.c	(working copy)
@@ -143,21 +143,21 @@
 
 	at = pos;
 
-	// skip any space at the start
+	/*  skip any space at the start */
 	while(at < size && char_isspace(in[at]))
 		++at;
 
-	// all space?  no word then
+	/*  all space?  no word then */
 	if(at >= size)
 		return 0;
 
-	// skip until a space or end
+	/*  skip until a space or end */
 	n = at;
 	while(n < size && !char_isspace(in[n]))
 		++n;
 	len = n - at;
 
-	// allocate length + zero byte
+	/*  allocate length + zero byte */
 	out = (unsigned char *)jdns_alloc(len + 1);
 	if(!out)
 		return 0;
@@ -177,7 +177,7 @@
 	jdns_string_t *outstr;
 	jdns_stringlist_t *wordlist;
 
-	// gather words and total of lengths
+	/*  gather words and total of lengths */
 	pos = 0;
 	total = 0;
 	wordlist = jdns_stringlist_new();
@@ -204,11 +204,11 @@
 		return outstr;
 	}
 
-	// we need to allocate space for total lengths and wordcount-1 spaces
+	/*  we need to allocate space for total lengths and wordcount-1 spaces */
 	outlen = total + (wordlist->count - 1);
 	out = (unsigned char *)jdns_alloc(outlen);
 
-	// lay out the words
+	/*  lay out the words */
 	pos = 0;
 	for(n = 0; n < wordlist->count; ++n)
 	{
@@ -217,7 +217,7 @@
 		memcpy(out + pos, data, size);
 		pos += size;
 
-		// if this is not the last word, append a space
+		/*  if this is not the last word, append a space */
 		if(n + 1 < wordlist->count)
 			out[pos++] = ' ';
 	}
@@ -254,8 +254,8 @@
 		{
 			if(at > 0)
 			{
-				// if we read at least one char, take it as a
-				//   line
+				/*  if we read at least one char, take it as a */
+				/*    line */
 				break;
 			}
 			else
@@ -298,7 +298,7 @@
 		if(!line)
 			break;
 
-		// truncate at comment
+		/*  truncate at comment */
 		n = string_indexOf(line, '#', 0);
 		if(n != -1)
 		{
@@ -367,7 +367,7 @@
 
 #ifdef JDNS_OS_WIN
 
-// from Microsoft IPTypes.h
+/*  from Microsoft IPTypes.h */
 #ifndef IP_TYPES_INCLUDED
 #define MAX_HOSTNAME_LEN    128
 #define MAX_DOMAIN_NAME_LEN 128
@@ -470,7 +470,7 @@
 	list_searchlist = 0;
 	if(str_searchlist)
 	{
-		// lowercase the string
+		/*  lowercase the string */
 		jdns_string_t *p = string_tolower(str_searchlist);
 		jdns_string_delete(str_searchlist);
 		str_searchlist = p;
@@ -482,12 +482,12 @@
 	params = jdns_dnsparams_new();
 	if(list_nameserver)
 	{
-		// qt seems to do a strange thing here by running each name
-		//   server address through the q3dns setLabel function, and
-		//   then pulls the result as a list of addresses.  i have
-		//   no idea why they do this, or how one IP address would
-		//   turn into anything else, let alone several addresses.
-		// so, uh, we're not going to do that.
+		/*  qt seems to do a strange thing here by running each name */
+		/*    server address through the q3dns setLabel function, and */
+		/*    then pulls the result as a list of addresses.  i have */
+		/*    no idea why they do this, or how one IP address would */
+		/*    turn into anything else, let alone several addresses. */
+		/*  so, uh, we're not going to do that. */
 		for(n = 0; n < list_nameserver->count; ++n)
 		{
 			jdns_address_t *addr = jdns_address_new();
@@ -587,13 +587,13 @@
 
 static void apply_win_hosts_file(jdns_dnsparams_t *a)
 {
-	// windows 64-bit
+	/*  windows 64-bit */
 	apply_hosts_var_filepath(a, "SystemRoot", "\\SysWOW64\\drivers\\etc\\hosts");
 
-	// winnt+
+	/*  winnt+ */
 	apply_hosts_var_filepath(a, "SystemRoot", "\\system32\\drivers\\etc\\hosts");
 
-	// win9x
+	/*  win9x */
 	apply_hosts_var_filepath(a, "WINDIR", "\\hosts");
 }
 
@@ -605,22 +605,22 @@
 	reg_params = dnsparams_get_winreg();
 	sys_params = dnsparams_get_winsys();
 
-	// no sys params?  take the reg params then
+	/*  no sys params?  take the reg params then */
 	if(!sys_params)
 	{
 		apply_win_hosts_file(reg_params);
 		return reg_params;
 	}
 
-	// sys params don't have a search list, so merge the domains from
-	//   the registry if possible
+	/*  sys params don't have a search list, so merge the domains from */
+	/*    the registry if possible */
 	if(reg_params)
 	{
 		for(n = 0; n < reg_params->domains->count; ++n)
 		{
 			jdns_string_t *reg_str = reg_params->domains->item[n];
 
-			// don't add dups
+			/*  don't add dups */
 			if(!dnsparams_have_domain(sys_params, reg_str))
 				jdns_dnsparams_append_domain(sys_params, reg_str);
 		}
@@ -653,7 +653,7 @@
 		if(!line)
 			break;
 
-		// truncate at comment
+		/*  truncate at comment */
 		n = string_indexOf(line, '#', 0);
 		if(n != -1)
 		{
@@ -711,7 +711,7 @@
 #ifdef JDNS_OS_MAC
 	res_init_func mac_res_init;
 
-	// look up res_init in the system library (qt does this, not sure why)
+	/*  look up res_init in the system library (qt does this, not sure why) */
 	mac_res_init = (res_init_func)dlsym(RTLD_NEXT, "res_init");
 	if(!mac_res_init)
 		return -1;
@@ -722,10 +722,10 @@
 }
 #endif
 
-// on some platforms, __res_state_ext exists as a struct but it is not
-//   a define, so the #ifdef doesn't work.  as a workaround, we'll explicitly
-//   specify the platforms that have __res_state_ext
-//#ifdef __res_state_ext
+/*  on some platforms, __res_state_ext exists as a struct but it is not */
+/*    a define, so the #ifdef doesn't work.  as a workaround, we'll explicitly */
+/*    specify the platforms that have __res_state_ext */
+/* #ifdef __res_state_ext */
 #if defined(JDNS_OS_MAC) || defined(JDNS_OS_FREEBSD) || \
     defined(JDNS_OS_NETBSD) || defined (JDNS_OS_SOLARIS)
 # define USE_EXTEXT
@@ -748,18 +748,18 @@
 
 	params = jdns_dnsparams_new();
 
-	// error initializing?
+	/*  error initializing? */
 	if(n == -1)
 		return params;
 
-	// nameservers - ipv6
+	/*  nameservers - ipv6 */
 	for(n = 0; n < MAXNS && n < RESVAR._u._ext.nscount; ++n)
 	{
 		jdns_address_t *addr;
 		struct sockaddr_in6 *sa6;
 
 #ifdef USE_EXTEXT
-		// seems _ext.ext can be null in some cases...
+		/*  seems _ext.ext can be null in some cases... */
 		if(RESVAR._u._ext.ext == NULL)
 			break;
 
@@ -776,7 +776,7 @@
 		jdns_address_delete(addr);
 	}
 
-	// nameservers - ipv4
+	/*  nameservers - ipv4 */
 	for(n = 0; n < MAXNS && n < RESVAR.nscount; ++n)
 	{
 		jdns_address_t *addr = jdns_address_new();
@@ -785,7 +785,7 @@
 		jdns_address_delete(addr);
 	}
 
-	// domain name
+	/*  domain name */
 	if(strlen(RESVAR.defdname) > 0)
 	{
 		jdns_string_t *str;
@@ -799,7 +799,7 @@
 		jdns_string_delete(str);
 	}
 
-	// search list
+	/*  search list */
 #ifdef MAXDFLSRCH
 	for(n = 0; n < MAXDFLSRCH && RESVAR.dnsrch[n]; ++n)
 	{
@@ -813,7 +813,7 @@
 			jdns_string_delete(str);
 			str = p;
 
-			// don't add dups
+			/*  don't add dups */
 			if(!dnsparams_have_domain(params, str))
 				jdns_dnsparams_append_domain(params, str);
 
@@ -829,7 +829,7 @@
 {
 	jdns_dnsparams_t *params;
 
-	// prefer system calls over files
+	/*  prefer system calls over files */
 	params = dnsparams_get_unixsys();
 	if(params->nameservers->count == 0)
 	{
Index: src/jdns/jdns.c
===================================================================
--- src/jdns/jdns.c	(revision 1355305)
+++ src/jdns/jdns.c	(working copy)
@@ -33,17 +33,17 @@
 #define JDNS_UDP_MUL_OUT_MAX  9000
 #define JDNS_UDP_MUL_IN_MAX   16384
 
-// cache no more than 7 days
+/*  cache no more than 7 days */
 #define JDNS_TTL_MAX          (86400 * 7)
 #define JDNS_CACHE_MAX        16384
 #define JDNS_CNAME_MAX        16
 #define JDNS_QUERY_MAX        4096
 
-//----------------------------------------------------------------------------
-// util
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  util */
+/* ---------------------------------------------------------------------------- */
 
-// declare this here, but implement it later after we define jdns_session_t
+/*  declare this here, but implement it later after we define jdns_session_t */
 static void _debug_line(jdns_session_t *s, const char *format, ...);
 
 static unsigned char _hex_nibble(unsigned char c)
@@ -75,7 +75,7 @@
 		return out;
 	}
 
-	// make room for the largest possible result
+	/*  make room for the largest possible result */
 	buf = (unsigned char *)malloc(size * 4);
 	i = 0;
 	for(n = 0; n < size; ++n)
@@ -120,15 +120,15 @@
 	unsigned char *out;
 	int len;
 
-	// truncate
+	/*  truncate */
 	len = _ustrlen(in);
 	if(len > 254)
 		len = 254;
 
-	// add a dot to the end if needed
+	/*  add a dot to the end if needed */
 	if(in[len - 1] != '.' && len < 254)
 	{
-		out = (unsigned char *)malloc(len + 2); // a dot and a zero
+		out = (unsigned char *)malloc(len + 2); /*  a dot and a zero */
 		memcpy(out, in, len);
 		out[len] = '.';
 		out[len+1] = 0;
@@ -136,7 +136,7 @@
 	}
 	else
 	{
-		out = (unsigned char *)malloc(len + 1); // a zero
+		out = (unsigned char *)malloc(len + 1); /*  a zero */
 		memcpy(out, in, len);
 		out[len] = 0;
 	}
@@ -190,7 +190,7 @@
 				return 0;
 			break;
 		case JDNS_RTYPE_MX:
-			// unsupported
+			/*  unsupported */
 			return 0;
 		case JDNS_RTYPE_SRV:
 			if(a->data.server->port != b->data.server->port
@@ -217,7 +217,7 @@
 				return 0;
 			break;
 		case JDNS_RTYPE_NS:
-			// unsupported
+			/*  unsupported */
 			return 0;
 		default:
 			if(!_cmp_rdata(a, b))
@@ -243,16 +243,16 @@
 		rr = jdns_rr_from_resource(res, packet);
 		if(!rr)
 			continue;
-		// if qname is set, restrict answers to those that match
-		//  the question
+		/*  if qname is set, restrict answers to those that match */
+		/*   the question */
 		put_in_answer = 1;
 		if(qname)
 		{
-			// name must match. type must either match or be CNAME,
-			//   unless the query was for any type
+			/*  name must match. type must either match or be CNAME, */
+			/*    unless the query was for any type */
 			if((qtype != JDNS_RTYPE_ANY && res->qtype != qtype && res->qtype != JDNS_RTYPE_CNAME) || !jdns_domain_cmp(res->qname->data, qname))
 			{
-				// put unusable records in additional section
+				/*  put unusable records in additional section */
 				put_in_answer = 0;
 			}
 		}
@@ -289,10 +289,10 @@
 	return r;
 }
 
-// size must be 1 to 16
+/*  size must be 1 to 16 */
 static void _print_hexdump_line(jdns_session_t *s, const unsigned char *buf, int size)
 {
-	char line[67]; // 3 * 16 + 2 + 16 + zero byte
+	char line[67]; /*  3 * 16 + 2 + 16 + zero byte */
 	int n;
 
 	memset(line, ' ', 66);
@@ -393,12 +393,12 @@
 
 	ownerstr = jdns_string_new();
 
-	// not the expected owner?
+	/*  not the expected owner? */
 	if(!owner || !jdns_domain_cmp(owner, rr->owner))
 	{
 		unsigned char *buf;
 		jdns_string_t *str = _make_printable_cstr((const char *)rr->owner);
-		buf = (unsigned char *)malloc(str->size + 3); // " [%s]"
+		buf = (unsigned char *)malloc(str->size + 3); /*  " [%s]" */
 		buf[0] = ' ';
 		buf[1] = '[';
 		memcpy(buf + 2, str->data, str->size);
@@ -509,9 +509,9 @@
 	return (a < b) ? a : b;
 }
 
-//----------------------------------------------------------------------------
-// jdns_event
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns_event */
+/* ---------------------------------------------------------------------------- */
 jdns_event_t *jdns_event_new()
 {
 	jdns_event_t *e = alloc_type(jdns_event_t);
@@ -527,9 +527,9 @@
 	jdns_free(e);
 }
 
-//----------------------------------------------------------------------------
-// jdns - internal types
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns - internal types */
+/* ---------------------------------------------------------------------------- */
 typedef struct list_item
 {
 	void (*dtor)(void *);
@@ -683,56 +683,56 @@
 
 	int id;
 
-	// user request ids
+	/*  user request ids */
 	int req_ids_count;
 	int *req_ids;
 
-	// packet id
+	/*  packet id */
 	int dns_id;
 
-	// what we are looking up
+	/*  what we are looking up */
 	unsigned char *qname;
 	int qtype;
 
-	// how many transmission attempts we have done.  note this
-	//  is not actually how many packets have been sent, since
-	//  it is possible for the first transmission to send many
-	//  at once.  this variable lets us decide when to give up.
-	//  (idea taken from qdns).
-	// set to -1 to deactivate (stop sending packets)
+	/*  how many transmission attempts we have done.  note this */
+	/*   is not actually how many packets have been sent, since */
+	/*   it is possible for the first transmission to send many */
+	/*   at once.  this variable lets us decide when to give up. */
+	/*   (idea taken from qdns). */
+	/*  set to -1 to deactivate (stop sending packets) */
 	int step;
 
-	// which nameservers we've tried (stored as a list of ids)
+	/*  which nameservers we've tried (stored as a list of ids) */
 	int servers_tried_count;
 	int *servers_tried;
 
-	// which servers we shouldn't try again
+	/*  which servers we shouldn't try again */
 	int servers_failed_count;
 	int *servers_failed;
 
-	// flag to indicate whether or not we've tried all available
-	//  nameservers already.  this means that all future
-	//  transmissions are likely repeats, and should be slowed
-	//  down.
+	/*  flag to indicate whether or not we've tried all available */
+	/*   nameservers already.  this means that all future */
+	/*   transmissions are likely repeats, and should be slowed */
+	/*   down. */
 	int retrying;
 
-	// flag to indicate if we've received nxdomain as an error so far
+	/*  flag to indicate if we've received nxdomain as an error so far */
 	int nxdomain;
 
-	// holds a timeout for the next step (time_start == -1 means no timer)
+	/*  holds a timeout for the next step (time_start == -1 means no timer) */
 	int time_start;
 	int time_next;
 
-	// whether or not to look in the cache for this query
+	/*  whether or not to look in the cache for this query */
 	int trycache;
 
-	// cname subquerying.  only cname_parent or cname_child may be set,
-	//  never both.
+	/*  cname subquerying.  only cname_parent or cname_child may be set, */
+	/*   never both. */
 	int cname_chain_count;
 	struct query *cname_parent;
 	struct query *cname_child;
 
-	// accumulates known multicast records to prevent duplicates
+	/*  accumulates known multicast records to prevent duplicates */
 	jdns_response_t *mul_known;
 } query_t;
 
@@ -812,14 +812,14 @@
 {
 	int n;
 
-	// all failed servers must continue to be considered tried servers, so
-	//   only clear tried servers that haven't failed
+	/*  all failed servers must continue to be considered tried servers, so */
+	/*    only clear tried servers that haven't failed */
 	for(n = 0; n < q->servers_tried_count; ++n)
 	{
 		if(!query_server_failed(q, q->servers_tried[n]))
 		{
 			_intarray_remove(&q->servers_tried, &q->servers_tried_count, n);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
@@ -858,11 +858,11 @@
 	unsigned char *data;
 	int size;
 
-	// query association
+	/*  query association */
 	query_t *query;
-	int query_send_type; // 0 == normal, 1 == first step send-all
+	int query_send_type; /*  0 == normal, 1 == first step send-all */
 
-	// name server association
+	/*  name server association */
 	int ns_id;
 } datagram_t;
 
@@ -896,7 +896,7 @@
 	int qtype;
 	int time_start;
 	int ttl;
-	jdns_rr_t *record; // if zero, nxdomain is assumed
+	jdns_rr_t *record; /*  if zero, nxdomain is assumed */
 } cache_item_t;
 
 void cache_item_delete(cache_item_t *e);
@@ -977,9 +977,9 @@
 	jdns_free(a);
 }
 
-//----------------------------------------------------------------------------
-// jdns
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns */
+/* ---------------------------------------------------------------------------- */
 struct jdns_session
 {
 	jdns_callbacks_t cb;
@@ -999,12 +999,12 @@
 	list_t *events;
 	list_t *cache;
 
-	// for blocking req_ids from reuse until user explicitly releases
+	/*  for blocking req_ids from reuse until user explicitly releases */
 	int do_hold_req_ids;
 	int held_req_ids_count;
 	int *held_req_ids;
 
-	// mdns
+	/*  mdns */
 	mdnsd mdns;
 	list_t *published;
 	jdns_address_t *maddr;
@@ -1065,7 +1065,7 @@
 	free(s);
 }
 
-// declare some internal functions
+/*  declare some internal functions */
 static int _callback_time_now(mdnsd d, void *arg);
 static int _callback_rand_int(mdnsd d, void *arg);
 
@@ -1090,7 +1090,7 @@
 {
 	int pos;
 
-	// make sure we don't hold an id twice
+	/*  make sure we don't hold an id twice */
 	pos = _intarray_indexOf(s->held_req_ids, s->held_req_ids_count, req_id);
 	if(pos != -1)
 		return;
@@ -1133,7 +1133,7 @@
 	return x;
 }
 
-// starts at 0
+/*  starts at 0 */
 static int get_next_qid(jdns_session_t *s)
 {
 	int n, id;
@@ -1153,7 +1153,7 @@
 	return id;
 }
 
-// starts at 1
+/*  starts at 1 */
 static int get_next_req_id(jdns_session_t *s)
 {
 	int n, k, id;
@@ -1162,7 +1162,7 @@
 	{
 		id = _int_wrap(&s->next_req_id, 1);
 
-		// no query using this?
+		/*  no query using this? */
 		for(n = 0; n < s->queries->count; ++n)
 		{
 			query_t *q = (query_t *)s->queries->item[n];
@@ -1178,7 +1178,7 @@
 				break;
 		}
 
-		// no publish using this?
+		/*  no publish using this? */
 		for(n = 0; n < s->published->count; ++n)
 		{
 			if(((published_item_t *)s->published->item[n])->id == id)
@@ -1188,10 +1188,10 @@
 			}
 		}
 
-		// successful unicast queries or any kind of error result in
-		//   events for actions that are no longer active.  we need
-		//   to make sure ids for these actions are not reassigned
-		//   until the user explicitly releases them
+		/*  successful unicast queries or any kind of error result in */
+		/*    events for actions that are no longer active.  we need */
+		/*    to make sure ids for these actions are not reassigned */
+		/*    until the user explicitly releases them */
 		for(n = 0; n < s->held_req_ids_count; ++n)
 		{
 			if(s->held_req_ids[n] == id)
@@ -1204,7 +1204,7 @@
 	return id;
 }
 
-// random number fitting in 16 bits
+/*  random number fitting in 16 bits */
 static int get_next_dns_id(jdns_session_t *s)
 {
 	int n, id, active_ids;
@@ -1212,7 +1212,7 @@
 	id = -1;
 	while(id == -1)
 	{
-		// use random number for dns id
+		/*  use random number for dns id */
 		id = s->cb.rand_int(s, s->cb.app) & 0xffff;
 
 		for(n = 0; n < s->queries->count; ++n)
@@ -1235,7 +1235,7 @@
 	return id;
 }
 
-// starts at 0
+/*  starts at 0 */
 static int get_next_name_server_id(jdns_session_t *s)
 {
 	int n, id;
@@ -1278,7 +1278,7 @@
 	s->port = port;
 	s->maddr = jdns_address_copy(maddr);
 
-	// class 1.  note: frame size is ignored by the jdns version of mdnsd
+	/*  class 1.  note: frame size is ignored by the jdns version of mdnsd */
 	s->mdns = mdnsd_new(0x0001, 1000, s->port, _callback_time_now, _callback_rand_int, s);
 	return 1;
 }
@@ -1286,14 +1286,14 @@
 void jdns_shutdown(jdns_session_t *s)
 {
 	if(s->shutdown == 0)
-		s->shutdown = 1; // request shutdown
+		s->shutdown = 1; /*  request shutdown */
 }
 
 void jdns_set_nameservers(jdns_session_t *s, const jdns_nameserverlist_t *nslist)
 {
 	int n, k;
 
-	// removed?
+	/*  removed? */
 	for(k = 0; k < s->name_servers->count; ++k)
 	{
 		name_server_t *ns = (name_server_t *)(s->name_servers->item[k]);
@@ -1312,19 +1312,19 @@
 			int i;
 			int ns_id;
 
-			// remove any pending packets to this nameserver
+			/*  remove any pending packets to this nameserver */
 			_remove_name_server_datagrams(s, ns->id);
 
 			_debug_line(s, "ns [%s:%d] (id=%d) removed", ns->address->c_str, ns->port, ns->id);
 			ns_id = ns->id;
 			list_remove(s->name_servers, ns);
-			--k; // adjust position
+			--k; /*  adjust position */
 			for(i = 0; i < s->queries->count; ++i)
 				query_name_server_gone((query_t *)s->queries->item[i], ns_id);
 		}
 	}
 
-	// added?
+	/*  added? */
 	for(n = 0; n < nslist->count; ++n)
 	{
 		name_server_t *ns;
@@ -1357,17 +1357,17 @@
 		}
 	}
 
-	// no nameservers?
+	/*  no nameservers? */
 	if(nslist->count == 0)
 	{
 		_debug_line(s, "nameserver count is zero, invalidating any queries");
 
-		// invalidate all of the queries!
+		/*  invalidate all of the queries! */
 		for(n = 0; n < s->queries->count; ++n)
 		{
 			query_t *q = (query_t *)s->queries->item[n];
 
-			// report event to any requests listening
+			/*  report event to any requests listening */
 			for(k = 0; k < q->req_ids_count; ++k)
 			{
 				jdns_event_t *event = jdns_event_new();
@@ -1377,12 +1377,12 @@
 				_append_event_and_hold_id(s, event);
 			}
 
-			// this line is probably redundant, but just for
-			//  consistency we'll do it...
+			/*  this line is probably redundant, but just for */
+			/*   consistency we'll do it... */
 			_remove_query_datagrams(s, q);
 
 			list_remove(s->queries, q);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
@@ -1412,7 +1412,7 @@
 		if(e->event->type == event_type && e->event->id == id)
 		{
 			list_remove(s->events, e);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
@@ -1423,21 +1423,21 @@
 
 	_unhold_req_id(s, id);
 
-	// remove any events associated with the query.  this avoids any
-	//   possibility that stale events from one query are mistaken to be
-	//   events resulting from a later query that happened to reuse the
-	//   id.  it also means we don't deliver events for cancelled queries,
-	//   which can simplify application logic.
+	/*  remove any events associated with the query.  this avoids any */
+	/*    possibility that stale events from one query are mistaken to be */
+	/*    events resulting from a later query that happened to reuse the */
+	/*    id.  it also means we don't deliver events for cancelled queries, */
+	/*    which can simplify application logic. */
 	_remove_events(s, JDNS_EVENT_RESPONSE, id);
 
-	// multicast
+	/*  multicast */
 	if(s->mode == 1)
 	{
 		_multicast_cancel(s, id);
 		return;
 	}
 
-	// unicast
+	/*  unicast */
 	for(n = 0; n < s->queries->count; ++n)
 	{
 		query_t *q = (query_t *)s->queries->item[n];
@@ -1445,15 +1445,15 @@
 		{
 			query_remove_req_id(q, id);
 
-			// note: calling _unicast_cancel might remove an item
-			//  from s->queries, thereby screwing up our iterator
-			//  position, but that's ok because we just break
-			//  anyway.
+			/*  note: calling _unicast_cancel might remove an item */
+			/*   from s->queries, thereby screwing up our iterator */
+			/*   position, but that's ok because we just break */
+			/*   anyway. */
 
-			// if no one else is depending on this request, then take action
+			/*  if no one else is depending on this request, then take action */
 			if(q->req_ids_count == 0 && !q->cname_parent)
 			{
-				// remove a possible cname child
+				/*  remove a possible cname child */
 				if(q->cname_child && q->cname_child->req_ids_count == 0)
 				{
 					q->cname_child->cname_parent = 0;
@@ -1492,7 +1492,7 @@
 	int now, passed;
 	int ret;
 
-	// session is shut down
+	/*  session is shut down */
 	if(s->shutdown == 2)
 		return 0;
 
@@ -1545,14 +1545,14 @@
 	_set_hold_ids_enabled(s, enabled);
 }
 
-//----------------------------------------------------------------------------
-// jdns - internal functions
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns - internal functions */
+/* ---------------------------------------------------------------------------- */
 
-// we don't have vsnprintf on windows, so don't pass anything enormous to
-//   this function.  the plan is that no line should exceed 1000 bytes,
-//   although _print_rr() might get close.  a 2048 byte buffer should be
-//   plenty then.
+/*  we don't have vsnprintf on windows, so don't pass anything enormous to */
+/*    this function.  the plan is that no line should exceed 1000 bytes, */
+/*    although _print_rr() might get close.  a 2048 byte buffer should be */
+/*    plenty then. */
 void _debug_line(jdns_session_t *s, const char *format, ...)
 {
 	char *buf = (char *)malloc(2048);
@@ -1568,7 +1568,7 @@
 {
 	jdns_session_t *s = (jdns_session_t *)arg;
 	(void)d;
-	// offset the time, mdnsd doesn't like starting at 0
+	/*  offset the time, mdnsd doesn't like starting at 0 */
 	return s->cb.time_now(s, s->cb.app) + 120 * 1000;
 }
 
@@ -1602,7 +1602,7 @@
 		if(a->ns_id == ns_id)
 		{
 			list_remove(s->outgoing, a);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
@@ -1616,14 +1616,14 @@
 		if(a->query == q)
 		{
 			list_remove(s->outgoing, a);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
 
 void _process_message(jdns_session_t *s, jdns_packet_t *p, int now, query_t *q, name_server_t *ns);
 
-// return 1 if 'q' should be deleted, 0 if not
+/*  return 1 if 'q' should be deleted, 0 if not */
 int _process_response(jdns_session_t *s, jdns_response_t *r, int nxdomain, int now, query_t *q);
 
 jdns_response_t *_cache_get_response(jdns_session_t *s, const unsigned char *qname, int qtype, int *_lowest_timeleft)
@@ -1728,19 +1728,19 @@
 
 void _unicast_cancel(jdns_session_t *s, query_t *q)
 {
-	// didn't even do a step yet?  just remove it
+	/*  didn't even do a step yet?  just remove it */
 	if(q->step == 0)
 	{
 		_remove_query_datagrams(s, q);
 		list_remove(s->queries, q);
 	}
-	// otherwise, just deactivate
+	/*  otherwise, just deactivate */
 	else
 	{
-		// deactivate and remain in the background for
-		//  1 minute.  this will allow us to cache a
-		//  reply, even if the user is not currently
-		//  interested.
+		/*  deactivate and remain in the background for */
+		/*   1 minute.  this will allow us to cache a */
+		/*   reply, even if the user is not currently */
+		/*   interested. */
 		q->step = -1;
 		q->time_start = s->cb.time_now(s, s->cb.app);
 		q->time_next = 60000;
@@ -1754,7 +1754,7 @@
 
 	packet = jdns_packet_new();
 	packet->id = q->dns_id;
-	packet->opts.rd = recurse; // recursion desired
+	packet->opts.rd = recurse; /*  recursion desired */
 	{
 		jdns_packet_question_t *question = jdns_packet_question_new();
 		question->qname = jdns_string_new();
@@ -1786,10 +1786,10 @@
 	list_insert(s->outgoing, a, -1);
 }
 
-// return 1 if packets still need to be written
+/*  return 1 if packets still need to be written */
 int _unicast_do_writes(jdns_session_t *s, int now);
 
-// return 1 if packets still need to be read
+/*  return 1 if packets still need to be read */
 int _unicast_do_reads(jdns_session_t *s, int now);
 
 int jdns_step_unicast(jdns_session_t *s, int now)
@@ -1809,7 +1809,7 @@
 		return 0;
 	}
 
-	// expire cached items
+	/*  expire cached items */
 	for(n = 0; n < s->cache->count; ++n)
 	{
 		cache_item_t *i = (cache_item_t *)s->cache->item[n];
@@ -1819,14 +1819,14 @@
 			_debug_line(s, "cache exp [%s]", str->data);
 			jdns_string_delete(str);
 			list_remove(s->cache, i);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 
 	need_write = _unicast_do_writes(s, now);
 	need_read = _unicast_do_reads(s, now);
 
-	// calculate next timer (based on queries and cache)
+	/*  calculate next timer (based on queries and cache) */
 	for(n = 0; n < s->queries->count; ++n)
 	{
 		query_t *q = (query_t *)(s->queries->item[n]);
@@ -1859,9 +1859,9 @@
 		flags |= JDNS_STEP_TIMER;
 		s->next_timer = smallest_time;
 
-		// offset it a little bit, so that the user doesn't call
-		//  us too early, resulting in a no-op and another timer
-		//  of 1 millisecond.
+		/*  offset it a little bit, so that the user doesn't call */
+		/*   us too early, resulting in a no-op and another timer */
+		/*   of 1 millisecond. */
 		s->next_timer += 2;
 	}
 	if(need_read || need_write)
@@ -1884,7 +1884,7 @@
 
 		q = (query_t *)s->queries->item[n];
 
-		// nothing to do
+		/*  nothing to do */
 		if(q->time_start == -1)
 			continue;
 
@@ -1898,14 +1898,14 @@
 
 		if(q->trycache)
 		{
-			// is it cached?
+			/*  is it cached? */
 			int lowest_timeleft;
 			int qtype = q->qtype;
 			jdns_response_t *r;
 
 			r = _cache_get_response(s, q->qname, qtype, &lowest_timeleft);
 
-			// not found?  try cname
+			/*  not found?  try cname */
 			if(!r)
 			{
 				qtype = JDNS_RTYPE_CNAME;
@@ -1918,10 +1918,10 @@
 
 				_debug_line(s, "[%d] using cached answer", q->id);
 
-				// are any of the records about to expire in 3 minutes?
-				//  assume the client is interested in this record and
-				//  query it again "in the background" (but only
-				//  if we are not already doing so)
+				/*  are any of the records about to expire in 3 minutes? */
+				/*   assume the client is interested in this record and */
+				/*   query it again "in the background" (but only */
+				/*   if we are not already doing so) */
 				if(lowest_timeleft < (3 * 60 * 1000) && !_find_first_active_query(s, q->qname, q->qtype))
 				{
 					query_t *new_q;
@@ -1929,8 +1929,8 @@
 					_debug_line(s, "requerying for cached item about to expire");
 
 					new_q = _get_query(s, q->qname, q->qtype, 1);
-					new_q->retrying = 1; // slow it down
-					new_q->trycache = 0; // don't use the cache for this
+					new_q->retrying = 1; /*  slow it down */
+					new_q->trycache = 0; /*  don't use the cache for this */
 				}
 
 				nxdomain = r->answerCount == 0 ? 1 : 0;
@@ -1938,7 +1938,7 @@
 				{
 					_remove_query_datagrams(s, q);
 					list_remove(s->queries, q);
-					--n; // adjust position
+					--n; /*  adjust position */
 				}
 
 				jdns_response_delete(r);
@@ -1946,32 +1946,32 @@
 			}
 		}
 
-		// inactive
+		/*  inactive */
 		if(q->step == -1)
 		{
-			// time up on an inactive query?  remove it
+			/*  time up on an inactive query?  remove it */
 			_debug_line(s, "removing inactive query");
 			_remove_query_datagrams(s, q);
 			list_remove(s->queries, q);
-			--n; // adjust position
+			--n; /*  adjust position */
 			continue;
 		}
 
 		giveup = 0;
 
-		// too many tries, give up
+		/*  too many tries, give up */
 		if(q->step == 8)
 			giveup = 1;
 
-		// no nameservers, give up
-		//  (this would happen if someone removed all nameservers
-		//   during a query)
+		/*  no nameservers, give up */
+		/*   (this would happen if someone removed all nameservers */
+		/*    during a query) */
 		if(s->name_servers->count == 0)
 			giveup = 1;
 
 		if(giveup)
 		{
-			// report event to any requests listening
+			/*  report event to any requests listening */
 			for(k = 0; k < q->req_ids_count; ++k)
 			{
 				jdns_event_t *event = jdns_event_new();
@@ -1981,10 +1981,10 @@
 				_append_event_and_hold_id(s, event);
 			}
 
-			// report error to parent
+			/*  report error to parent */
 			if(q->cname_parent)
 			{
-				// report event to any requests listening
+				/*  report event to any requests listening */
 				query_t *cq = q->cname_parent;
 				for(k = 0; k < cq->req_ids_count; ++k)
 				{
@@ -1999,21 +1999,21 @@
 
 			_remove_query_datagrams(s, q);
 			list_remove(s->queries, q);
-			--n; // adjust position
+			--n; /*  adjust position */
 			continue;
 		}
 
-		// assign a packet id if we don't have one yet
+		/*  assign a packet id if we don't have one yet */
 		if(q->dns_id == -1)
 		{
 			q->dns_id = get_next_dns_id(s);
 
-			// couldn't get an id?
+			/*  couldn't get an id? */
 			if(q->dns_id == -1)
 			{
 				_debug_line(s, "unable to reserve packet id");
 
-				// report event to any requests listening
+				/*  report event to any requests listening */
 				for(k = 0; k < q->req_ids_count; ++k)
 				{
 					jdns_event_t *event = jdns_event_new();
@@ -2023,10 +2023,10 @@
 					_append_event_and_hold_id(s, event);
 				}
 
-				// report error to parent
+				/*  report error to parent */
 				if(q->cname_parent)
 				{
-					// report event to any requests listening
+					/*  report event to any requests listening */
 					query_t *cq = q->cname_parent;
 					for(k = 0; k < cq->req_ids_count; ++k)
 					{
@@ -2041,20 +2041,20 @@
 
 				_remove_query_datagrams(s, q);
 				list_remove(s->queries, q);
-				--n; // adjust position
+				--n; /*  adjust position */
 				continue;
 			}
 		}
 
-		// out of name servers?
+		/*  out of name servers? */
 		if(q->servers_tried_count == s->name_servers->count)
 		{
-			// clear the 'tried' list, and start over in retry mode
+			/*  clear the 'tried' list, and start over in retry mode */
 			query_clear_servers_tried(q);
 			q->retrying = 1;
 		}
 
-		// find a nameserver that has not been tried
+		/*  find a nameserver that has not been tried */
 		ns = 0;
 		for(k = 0; k < s->name_servers->count; ++k)
 		{
@@ -2066,9 +2066,9 @@
 			}
 		}
 
-		// in theory, it is not possible for 'ns' to be null here
+		/*  in theory, it is not possible for 'ns' to be null here */
 
-		// don't send the packet if there is already one in the queue
+		/*  don't send the packet if there is already one in the queue */
 		already_sending = 0;
 		for(k = 0; k < s->outgoing->count; ++k)
 		{
@@ -2080,13 +2080,13 @@
 			}
 		}
 
-		// send the query, with recursion desired, normal query_send_type
+		/*  send the query, with recursion desired, normal query_send_type */
 		if(!already_sending)
 			_queue_packet(s, q, ns, 1, 0);
 
 		query_add_server_tried(q, ns->id);
 
-		// if there is one query, then do a trick on the first step
+		/*  if there is one query, then do a trick on the first step */
 		/*if(s->queries->count == 1 && q->step == 0 && !q->retrying)
 		{
 			// query all other servers non-recursively
@@ -2102,10 +2102,10 @@
 			}
 		}*/
 
-		// out of name servers?
+		/*  out of name servers? */
 		if(q->servers_tried_count == s->name_servers->count)
 		{
-			// clear the 'tried' list, and start over in retry mode
+			/*  clear the 'tried' list, and start over in retry mode */
 			query_clear_servers_tried(q);
 			q->retrying = 1;
 		}
@@ -2115,7 +2115,7 @@
 		++q->step;
 	}
 
-	// try to send queued outgoing packets
+	/*  try to send queued outgoing packets */
 	for(n = 0; n < s->outgoing->count; ++n)
 	{
 		datagram_t *a = (datagram_t *)s->outgoing->item[n];
@@ -2139,7 +2139,7 @@
 		}
 
 		list_remove(s->outgoing, a);
-		--n; // adjust position
+		--n; /*  adjust position */
 	}
 
 	return need_write;
@@ -2179,7 +2179,7 @@
 			_debug_line(s, "cache del [%s]", str->data);
 			jdns_string_delete(str);
 			list_remove(s->cache, i);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
@@ -2196,14 +2196,14 @@
 			_debug_line(s, "cache del [%s]", str->data);
 			jdns_string_delete(str);
 			list_remove(s->cache, i);
-			--n; // adjust position
+			--n; /*  adjust position */
 		}
 	}
 }
 
-// same as _cache_add, but make sure the exact same record (name AND value)
-//   isn't stored twice, and make sure no more than one cname record per name
-//   is stored.
+/*  same as _cache_add, but make sure the exact same record (name AND value) */
+/*    isn't stored twice, and make sure no more than one cname record per name */
+/*    is stored. */
 void _cache_add_no_dups(jdns_session_t *s, const unsigned char *qname, int qtype, int time_start, int ttl, const jdns_rr_t *record)
 {
 	if(qtype == JDNS_RTYPE_CNAME)
@@ -2219,8 +2219,8 @@
 	int need_read;
 	int n, k;
 
-	// let's always ask for reads, just so the user doesn't have to
-	//  worry about what should happen to incoming packets otherwise
+	/*  let's always ask for reads, just so the user doesn't have to */
+	/*   worry about what should happen to incoming packets otherwise */
 	need_read = 1;
 
 	if(!s->handle_readable)
@@ -2240,7 +2240,7 @@
 		addr = jdns_address_new();
 		ret = s->cb.udp_read(s, s->cb.app, s->handle, addr, &port, buf, &bufsize);
 
-		// no packet?
+		/*  no packet? */
 		if(ret == 0)
 		{
 			s->handle_readable = 0;
@@ -2270,7 +2270,7 @@
 			continue;
 		}
 
-		// who does it belong to?
+		/*  who does it belong to? */
 		q = 0;
 		ns = 0;
 		for(n = 0; n < s->queries->count; ++n)
@@ -2288,7 +2288,7 @@
 
 		if(q)
 		{
-			// what name server did it come from?
+			/*  what name server did it come from? */
 			for(k = 0; k < s->name_servers->count; ++k)
 			{
 				name_server_t *i = (name_server_t *)s->name_servers->item[k];
@@ -2299,9 +2299,9 @@
 				}
 			}
 
-			// none? maybe that's because we're using unicast
-			//   over multicast, where responses always come
-			//   from an unexpected address
+			/*  none? maybe that's because we're using unicast */
+			/*    over multicast, where responses always come */
+			/*    from an unexpected address */
 			if(!ns && s->name_servers->count > 0)
 			{
 				name_server_t *i;
@@ -2316,23 +2316,23 @@
 				jdns_address_delete(m6);
 			}
 
-			// no suitable name server
+			/*  no suitable name server */
 			if(!ns)
 			{
-				// setting q = 0 causes the response to be
-				//   ignored.  earlier versions of jdns would
-				//   do this, but now we comment it out because
-				//   the behavior is too strict.
-				//q = 0;
+				/*  setting q = 0 causes the response to be */
+				/*    ignored.  earlier versions of jdns would */
+				/*    do this, but now we comment it out because */
+				/*    the behavior is too strict. */
+				/* q = 0; */
 
-				// instead we'll just print a warning
+				/*  instead we'll just print a warning */
 				_debug_line(s, "warning: response from unexpected nameserver");
 			}
 		}
 
 		jdns_address_delete(addr);
 
-		// no queries?  eat the packet
+		/*  no queries?  eat the packet */
 		if(!q)
 		{
 			_debug_line(s, "no such query for packet");
@@ -2362,8 +2362,8 @@
 		return;
 	}
 
-	// we don't test RA (recursion available)
-	// we don't test the extra Z fields
+	/*  we don't test RA (recursion available) */
+	/*  we don't test the extra Z fields */
 
 	authoritative = packet->opts.aa;
 	truncated = packet->opts.tc;
@@ -2374,19 +2374,19 @@
 
 	r = 0;
 
-	// nxdomain
+	/*  nxdomain */
 	if(packet->opts.rcode == 3)
 	{
-		// treat nxdomain as a generic error, but at the same time flag
-		//   the fact that it was received.  this ensures that
-		//   resolving keeps going, in case the user has multiple dns
-		//   servers and one of them reports nxdomain when a later one
-		//   would succeed.  if all of the servers fail then this flag
-		//   can be used at the end to report nxdomain instead of a
-		//   generic error.
+		/*  treat nxdomain as a generic error, but at the same time flag */
+		/*    the fact that it was received.  this ensures that */
+		/*    resolving keeps going, in case the user has multiple dns */
+		/*    servers and one of them reports nxdomain when a later one */
+		/*    would succeed.  if all of the servers fail then this flag */
+		/*    can be used at the end to report nxdomain instead of a */
+		/*    generic error. */
 		q->nxdomain = 1;
 	}
-	// normal
+	/*  normal */
 	else if(packet->opts.rcode == 0)
 	{
 		int at_least_something;
@@ -2405,7 +2405,7 @@
 		}
 		else
 		{
-			// note: why does qdns care about recursion_desired here?
+			/*  note: why does qdns care about recursion_desired here? */
 			if(authoritative && recursion_desired)
 				success = 1;
 		}
@@ -2417,19 +2417,19 @@
 		}
 	}
 
-	// caching
+	/*  caching */
 	if(r)
 	{
 		int cache_answers;
 		int cache_additional;
 
-		// clear past items
+		/*  clear past items */
 		_cache_remove_all_of_kind(s, q->qname, q->qtype);
 
 		cache_answers = 1;
 		cache_additional = 1;
 
-		// if truncated, we may not want to cache
+		/*  if truncated, we may not want to cache */
 		if(truncated)
 		{
 			cache_additional = 0;
@@ -2456,17 +2456,17 @@
 		}
 	}
 
-	// don't pass authority/additional records upwards
+	/*  don't pass authority/additional records upwards */
 	if(r)
 		jdns_response_remove_extra(r);
 
-	// this server returned an error?
+	/*  this server returned an error? */
 	if(!r && ns)
 	{
-		// all failed servers must also be considered tried servers,
-		//   so mark as tried if necessary.  this can happen if the
-		//   tried list is cleared (to perform retrying) and then an
-		//   error is received
+		/*  all failed servers must also be considered tried servers, */
+		/*    so mark as tried if necessary.  this can happen if the */
+		/*    tried list is cleared (to perform retrying) and then an */
+		/*    error is received */
 		if(!query_server_tried(q, ns->id))
 			query_add_server_tried(q, ns->id);
 
@@ -2482,20 +2482,20 @@
 	jdns_response_delete(r);
 }
 
-// 'r' can be null, for processing an error
-// 'now' can be -1, if processing a cached response ('r' always non-null)
+/*  'r' can be null, for processing an error */
+/*  'now' can be -1, if processing a cached response ('r' always non-null) */
 int _process_response(jdns_session_t *s, jdns_response_t *r, int nxdomain, int now, query_t *q)
 {
 	int k;
 	int do_error = 0;
 	int do_nxdomain = 0;
 
-	// error
+	/*  error */
 	if(!r)
 	{
 		int all_errored;
 
-		// if not all servers have errored, ignore error
+		/*  if not all servers have errored, ignore error */
 		all_errored = 1;
 		for(k = 0; k < s->name_servers->count; ++k)
 		{
@@ -2511,12 +2511,12 @@
 
 		do_error = 1;
 
-		// if we picked up an nxdomain along the way, act on it now
+		/*  if we picked up an nxdomain along the way, act on it now */
 		if(q->nxdomain)
 		{
 			do_nxdomain = 1;
 
-			// cache nxdomain for 1 minute
+			/*  cache nxdomain for 1 minute */
 			if(q->qtype != JDNS_RTYPE_ANY && now != -1)
 			{
 				_cache_remove_all_of_kind(s, q->qname, q->qtype);
@@ -2532,7 +2532,7 @@
 
 	if(do_error)
 	{
-		// report event to any requests listening
+		/*  report event to any requests listening */
 		for(k = 0; k < q->req_ids_count; ++k)
 		{
 			jdns_event_t *event = jdns_event_new();
@@ -2545,10 +2545,10 @@
 			_append_event_and_hold_id(s, event);
 		}
 
-		// report error to parent
+		/*  report error to parent */
 		if(q->cname_parent)
 		{
-			// report event to any requests listening
+			/*  report event to any requests listening */
 			query_t *cq = q->cname_parent;
 			for(k = 0; k < cq->req_ids_count; ++k)
 			{
@@ -2564,17 +2564,17 @@
 		return 1;
 	}
 
-	// all we got was a cname that we didn't ask for?
+	/*  all we got was a cname that we didn't ask for? */
 	if(r->answerCount == 1 && r->answerRecords[0]->type == JDNS_RTYPE_CNAME && q->qtype != JDNS_RTYPE_CNAME)
 	{
 		query_t *new_q;
 
 		_debug_line(s, "all we got was a cname, following the chain ...");
 
-		// max chain count, bail
+		/*  max chain count, bail */
 		if(q->cname_chain_count >= JDNS_CNAME_MAX)
 		{
-			// report event to any requests listening
+			/*  report event to any requests listening */
 			for(k = 0; k < q->req_ids_count; ++k)
 			{
 				jdns_event_t *event = jdns_event_new();
@@ -2584,10 +2584,10 @@
 				_append_event_and_hold_id(s, event);
 			}
 
-			// report error to parent
+			/*  report error to parent */
 			if(q->cname_parent)
 			{
-				// report event to any requests listening
+				/*  report event to any requests listening */
 				query_t *cq = q->cname_parent;
 				for(k = 0; k < cq->req_ids_count; ++k)
 				{
@@ -2605,34 +2605,34 @@
 
 		new_q = _get_query(s, r->answerRecords[0]->data.name, q->qtype, 1);
 
-		// is the current query a child query? (has a parent)
+		/*  is the current query a child query? (has a parent) */
 		if(q->cname_parent)
 		{
-			// if so, then set new_q as the new child
+			/*  if so, then set new_q as the new child */
 			new_q->cname_chain_count = q->cname_chain_count + 1;
 			new_q->cname_parent = q->cname_parent;
 			new_q->cname_parent->cname_child = new_q;
 
-			// and delete the current query
+			/*  and delete the current query */
 			return 1;
 		}
 		else
 		{
-			// otherwise, the current query becomes a parent, with
-			//   new_q set as the child
+			/*  otherwise, the current query becomes a parent, with */
+			/*    new_q set as the child */
 			new_q->cname_chain_count = q->cname_chain_count + 1;
 			new_q->cname_parent = q;
 			q->cname_child = new_q;
 			q->time_start = -1;
-			q->dns_id = -1; // don't handle responses
+			q->dns_id = -1; /*  don't handle responses */
 		}
 	}
 
-	// if this query now has a child, then don't report events or delete
+	/*  if this query now has a child, then don't report events or delete */
 	if(q->cname_child)
 		return 0;
 
-	// report event to any requests listening
+	/*  report event to any requests listening */
 	for(k = 0; k < q->req_ids_count; ++k)
 	{
 		jdns_event_t *event = jdns_event_new();
@@ -2643,10 +2643,10 @@
 		_append_event_and_hold_id(s, event);
 	}
 
-	// report to parent
+	/*  report to parent */
 	if(q->cname_parent)
 	{
-		// report event to any requests listening
+		/*  report event to any requests listening */
 		query_t *cq = q->cname_parent;
 		for(k = 0; k < cq->req_ids_count; ++k)
 		{
@@ -2663,9 +2663,9 @@
 	return 1;
 }
 
-//----------------------------------------------------------------------------
-// jdns - multicast
-//----------------------------------------------------------------------------
+/* ---------------------------------------------------------------------------- */
+/*  jdns - multicast */
+/* ---------------------------------------------------------------------------- */
 static jdns_rr_t *_mdnsda2rr(mdnsda a)
 {
 	jdns_rr_t *rr;
@@ -2673,14 +2673,14 @@
 	if(a->type == JDNS_RTYPE_ANY)
 		return 0;
 
-	// for AAAA, TXT and HINFO, run the raw rdata through jdns_rr's parser
+	/*  for AAAA, TXT and HINFO, run the raw rdata through jdns_rr's parser */
 	if(a->type == JDNS_RTYPE_AAAA || a->type == JDNS_RTYPE_TXT || a->type == JDNS_RTYPE_HINFO)
 	{
 		jdns_packet_resource_t *pr = jdns_packet_resource_new();
 		pr->qname = jdns_string_new();
 		jdns_string_set_cstr(pr->qname, (const char *)a->name);
 		pr->qtype = a->type;
-		pr->qclass = 0x0001; // class is always 1 for us
+		pr->qclass = 0x0001; /*  class is always 1 for us */
 		if(a->ttl == 0)
 			pr->ttl = 0;
 		else
@@ -2688,15 +2688,15 @@
 		pr->rdata = jdns_copy_array(a->rdata, a->rdlen);
 		pr->rdlength = a->rdlen;
 
-		// we don't need a reference for these types
+		/*  we don't need a reference for these types */
 		rr = jdns_rr_from_resource(pr, 0);
 	}
-	// else, pull the values out of 'a' directly
+	/*  else, pull the values out of 'a' directly */
 	else
 	{
 		rr = jdns_rr_new();
 		rr->owner = _ustrdup(a->name);
-		rr->qclass = 0x0001; // class is always 1 for us
+		rr->qclass = 0x0001; /*  class is always 1 for us */
 		if(a->ttl == 0)
 			rr->ttl = 0;
 		else
@@ -2714,12 +2714,12 @@
 			}
 			case JDNS_RTYPE_AAAA:
 			{
-				// covered earlier
+				/*  covered earlier */
 				break;
 			}
 			case JDNS_RTYPE_MX:
 			{
-				// don't care about MX
+				/*  don't care about MX */
 				jdns_rr_delete(rr);
 				rr = 0;
 				break;
@@ -2741,17 +2741,17 @@
 			}
 			case JDNS_RTYPE_TXT:
 			{
-				// covered earlier
+				/*  covered earlier */
 				break;
 			}
 			case JDNS_RTYPE_HINFO:
 			{
-				// covered earlier
+				/*  covered earlier */
 				break;
 			}
 			case JDNS_RTYPE_NS:
 			{
-				// don't care about NS
+				/*  don't care about NS */
 				jdns_rr_delete(rr);
 				rr = 0;
 				break;
@@ -2778,7 +2778,7 @@
 
 	s = (jdns_session_t *)arg;
 
-	// what query is this for?
+	/*  what query is this for? */
 	q = 0;
 	for(n = 0; n < s->queries->count; ++n)
 	{
@@ -2790,7 +2790,7 @@
 		}
 	}
 
-	// note: this can't happen, but we'll check anyway
+	/*  note: this can't happen, but we'll check anyway */
 	if(!q)
 	{
 		_debug_line(s, "no such multicast query");
@@ -2801,7 +2801,7 @@
 	if(!rr)
 		return 0;
 
-	// add/remove as a known
+	/*  add/remove as a known */
 	if(rr->ttl == 0)
 	{
 		for(n = 0; n < q->mul_known->answerCount; ++n)
@@ -2821,7 +2821,7 @@
 	jdns_response_append_answer(r, rr);
 	jdns_rr_delete(rr);
 
-	// report event to any requests listening
+	/*  report event to any requests listening */
 	for(n = 0; n < q->req_ids_count; ++n)
 	{
 		event = jdns_event_new();
@@ -2842,7 +2842,7 @@
 	query_t *q;
 	jdns_string_t *str;
 
-	// check for existing queries
+	/*  check for existing queries */
 	for(n = 0; n < s->queries->count; ++n)
 	{
 		q = (query_t *)s->queries->item[n];
@@ -2880,7 +2880,7 @@
 	_debug_line(s, "query input: [%s]", str->data);
 	jdns_string_delete(str);
 
-	// add a dot to the end if needed
+	/*  add a dot to the end if needed */
 	qname = _fix_input(name);
 
 	q = _get_multicast_query(s, qname, qtype);
@@ -2888,7 +2888,7 @@
 	query_add_req_id(q, req_id);
 	free(qname);
 
-	// start the mdnsd_query if necessary
+	/*  start the mdnsd_query if necessary */
 	if(q->step == 0)
 	{
 		q->step = 1;
@@ -2898,7 +2898,7 @@
 	{
 		int n;
 
-		// report the knowns
+		/*  report the knowns */
 		for(n = 0; n < q->mul_known->answerCount; ++n)
 		{
 			const jdns_rr_t *rr;
@@ -2930,7 +2930,7 @@
 		{
 			query_remove_req_id(q, req_id);
 
-			// if no one else is depending on this request, then take action
+			/*  if no one else is depending on this request, then take action */
 			if(q->req_ids_count == 0)
 			{
 				mdnsd_query(s->mdns, (char *)q->qname, q->qtype, NULL, 0);
@@ -2950,7 +2950,7 @@
 
 	s = (jdns_session_t *)arg;
 
-	// find the associated pub item
+	/*  find the associated pub item */
 	pub = 0;
 	for(n = 0; n < s->published->count; ++n)
 	{
@@ -2962,7 +2962,7 @@
 		}
 	}
 
-	// note: this can't happen, but we'll check anyway
+	/*  note: this can't happen, but we'll check anyway */
 	if(!pub)
 	{
 		_debug_line(s, "no such multicast published item");
@@ -2993,7 +2993,7 @@
 		event->status = JDNS_STATUS_CONFLICT;
 		_append_event_and_hold_id(s, event);
 
-		// remove the item
+		/*  remove the item */
 		list_remove(s->published, pub);
 	}
 }
@@ -3035,10 +3035,10 @@
 
 static void _publish_applyrr_unknown(jdns_session_t *s, mdnsdr r, const jdns_rr_t *rr)
 {
-	// for unsupported/unknown, just take the rdata
-	// note: for this to work, the app must explicitly set the rdata.
-	//   if the record is MX or some other known but unsupported record
-	//   type, setting the known fields is not enough
+	/*  for unsupported/unknown, just take the rdata */
+	/*  note: for this to work, the app must explicitly set the rdata. */
+	/*    if the record is MX or some other known but unsupported record */
+	/*    type, setting the known fields is not enough */
 	mdnsd_set_raw(s->mdns, r, (char *)rr->rdata, rr->rdlength);
 }
 
@@ -3050,7 +3050,7 @@
 		return 1;
 	}
 
-	// jdns_mdnsd supports: A, AAAA, SRV, CNAME, PTR, TXT, and HINFO
+	/*  jdns_mdnsd supports: A, AAAA, SRV, CNAME, PTR, TXT, and HINFO */
 	switch(rr->type)
 	{
 		case JDNS_RTYPE_A:
@@ -3138,7 +3138,7 @@
 	r = 0;
 	next_id = get_next_req_id(s);
 
-	// see if we have an item with this name+type combination already
+	/*  see if we have an item with this name+type combination already */
 	pub = 0;
 	for(n = 0; n < s->published->count; ++n)
 	{
@@ -3172,7 +3172,7 @@
 	pub->rr = jdns_rr_copy(rr);
 	list_insert(s->published, pub, -1);
 
-	// mdnsd doesn't report publish events for shared, so do that here
+	/*  mdnsd doesn't report publish events for shared, so do that here */
 	if(mode == JDNS_PUBLISH_SHARED)
 		report_published(s, pub);
 
@@ -3183,11 +3183,11 @@
 
 	if(r)
 	{
-		// don't publish
+		/*  don't publish */
 		mdnsd_done(s->mdns, r);
 	}
 
-	// send an error to the app
+	/*  send an error to the app */
 	event = jdns_event_new();
 	event->type = JDNS_EVENT_PUBLISH;
 	event->id = next_id;
@@ -3218,10 +3218,10 @@
 
 	r = pub->rec;
 
-	// expire existing record.  this is mostly needed for shared records
-	//   since unique records already have the cache flush bit and that
-	//   should achieve the same result.  however, since Apple expires
-	//   unique records before updates, so will we.
+	/*  expire existing record.  this is mostly needed for shared records */
+	/*    since unique records already have the cache flush bit and that */
+	/*    should achieve the same result.  however, since Apple expires */
+	/*    unique records before updates, so will we. */
 	mdnsd_done(s->mdns, r);
 	if(pub->mode == JDNS_PUBLISH_UNIQUE)
 		r = mdnsd_unique(s->mdns, (char *)pub->rr->owner, pub->rr->type, rr->ttl, _multicast_pubresult, s);
@@ -3255,15 +3255,15 @@
 {
 	int n;
 
-	// to flush, we make like our queries and published items are all new.
-	// we'll do this by destroying/creating the mdnsd object again (so it
-	// is fresh) and then reapply all queries and published items to it.
+	/*  to flush, we make like our queries and published items are all new. */
+	/*  we'll do this by destroying/creating the mdnsd object again (so it */
+	/*  is fresh) and then reapply all queries and published items to it. */
 
-	// start over with mdnsd
+	/*  start over with mdnsd */
 	mdnsd_free(s->mdns);
 	s->mdns = mdnsd_new(0x0001, 1000, s->port, _callback_time_now, _callback_rand_int, s);
 
-	// attempt to publish again
+	/*  attempt to publish again */
 	for(n = 0; n < s->published->count; ++n)
 	{
 		published_item_t *i;
@@ -3278,12 +3278,12 @@
 		i->rec = r;
 	}
 
-	// restore the queries
+	/*  restore the queries */
 	for(n = 0; n < s->queries->count; ++n)
 	{
 		query_t *q = (query_t *)s->queries->item[n];
 
-		// issue the query
+		/*  issue the query */
 		mdnsd_query(s->mdns, (char *)q->qname, q->qtype, _multicast_query_ans, s);
 	}
 }
@@ -3295,7 +3295,7 @@
 	jdns_packet_t *packet;
 	int flags;
 
-	// not used
+	/*  not used */
 	(void)now;
 
 	need_read = 0;
@@ -3332,7 +3332,7 @@
 		buf = packet->raw_data;
 		buf_len = packet->raw_size;
 
-		// multicast
+		/*  multicast */
 		if(!addr)
 		{
 			addr = jdns_address_copy(s->maddr);
@@ -3347,7 +3347,7 @@
 		jdns_address_delete(addr);
 		jdns_packet_delete(packet);
 
-		// if we can't write the packet, oh well
+		/*  if we can't write the packet, oh well */
 		if(ret == 0)
 		{
 			s->handle_writable = 0;
@@ -3365,8 +3365,8 @@
 		return 0;
 	}
 
-	// let's always ask for reads, just so the user doesn't have to
-	//  worry about what should happen to incoming packets otherwise
+	/*  let's always ask for reads, just so the user doesn't have to */
+	/*   worry about what should happen to incoming packets otherwise */
 	need_read = 1;
 
 	if(s->handle_readable)
@@ -3383,7 +3383,7 @@
 			addr = jdns_address_new();
 			ret = s->cb.udp_read(s, s->cb.app, s->handle, addr, &port, buf, &bufsize);
 
-			// no packet?
+			/*  no packet? */
 			if(ret == 0)
 			{
 				s->handle_readable = 0;
@@ -3424,9 +3424,9 @@
 		flags |= JDNS_STEP_TIMER;
 		s->next_timer = smallest_time;
 
-		// offset it a little bit, so that the user doesn't call
-		//  us too early, resulting in a no-op and another timer
-		//  of 1 millisecond.
+		/*  offset it a little bit, so that the user doesn't call */
+		/*   us too early, resulting in a no-op and another timer */
+		/*   of 1 millisecond. */
 		s->next_timer += 2;
 	}
 	if(need_read || need_write)
Index: src/jdns/jdns.h
===================================================================
--- src/jdns/jdns.h	(revision 1355305)
+++ src/jdns/jdns.h	(working copy)
@@ -88,7 +88,7 @@
 	int str_len);
 void jdns_string_set_cstr(jdns_string_t *s, const char *str);
 
- // overlays jdns_list
+ /*  overlays jdns_list */
 typedef struct jdns_stringlist
 {
 	JDNS_OBJECT
@@ -107,7 +107,7 @@
 	union
 	{
 		unsigned long int v4;
-		unsigned char *v6; // 16 bytes
+		unsigned char *v6; /*  16 bytes */
 	} addr;
 	char *c_str;
 } jdns_address_t;
@@ -117,23 +117,23 @@
 void jdns_address_delete(jdns_address_t *a);
 void jdns_address_set_ipv4(jdns_address_t *a, unsigned long int ipv4);
 void jdns_address_set_ipv6(jdns_address_t *a, const unsigned char *ipv6);
-// return 1 if string was ok, else 0.  Note: IPv4 addresses only!
+/*  return 1 if string was ok, else 0.  Note: IPv4 addresses only! */
 int jdns_address_set_cstr(jdns_address_t *a, const char *str);
-// return 1 if the same, else 0
+/*  return 1 if the same, else 0 */
 int jdns_address_cmp(const jdns_address_t *a, const jdns_address_t *b);
 
-// convenient predefined addresses/ports
+/*  convenient predefined addresses/ports */
 #define JDNS_UNICAST_PORT    53
 #define JDNS_MULTICAST_PORT  5353
-jdns_address_t *jdns_address_multicast4_new(); // 224.0.0.251
-jdns_address_t *jdns_address_multicast6_new(); // FF02::FB
+jdns_address_t *jdns_address_multicast4_new(); /*  224.0.0.251 */
+jdns_address_t *jdns_address_multicast6_new(); /*  FF02::FB */
 
 typedef struct jdns_server
 {
 	unsigned char *name;
-	int port; // SRV only
+	int port; /*  SRV only */
 	int priority;
-	int weight; // SRV only
+	int weight; /*  SRV only */
 } jdns_server_t;
 
 jdns_server_t *jdns_server_new();
@@ -218,15 +218,15 @@
 
 	union
 	{
-		jdns_address_t *address;  // for A, AAAA
-		jdns_server_t *server;    // for MX, SRV
-		unsigned char *name;      // for CNAME, PTR, NS
-		jdns_stringlist_t *texts; // for TXT
+		jdns_address_t *address;  /*  for A, AAAA */
+		jdns_server_t *server;    /*  for MX, SRV */
+		unsigned char *name;      /*  for CNAME, PTR, NS */
+		jdns_stringlist_t *texts; /*  for TXT */
 		struct
 		{
 			jdns_string_t *cpu;
 			jdns_string_t *os;
-		} hinfo; // for HINFO
+		} hinfo; /*  for HINFO */
 	} data;
 } jdns_rr_t;
 
@@ -247,7 +247,7 @@
 void jdns_rr_set_HINFO(jdns_rr_t *r, const jdns_string_t *cpu,
 	const jdns_string_t *os);
 void jdns_rr_set_NS(jdns_rr_t *r, const unsigned char *name);
-// note: only works on known types
+/*  note: only works on known types */
 int jdns_rr_verify(const jdns_rr_t *r);
 
 typedef struct jdns_response
@@ -288,71 +288,71 @@
 
 typedef struct jdns_callbacks
 {
-	void *app; // user-supplied context
+	void *app; /*  user-supplied context */
 
-	// time_now:
-	//   s: session
-	//   app: user-supplied context
-	//   return: milliseconds since session started
+	/*  time_now: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    return: milliseconds since session started */
 	int (*time_now)(jdns_session_t *s, void *app);
 
-	// rand_int:
-	//   s: session
-	//   app: user-supplied context
-	//   return: random integer between 0-65535
+	/*  rand_int: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    return: random integer between 0-65535 */
 	int (*rand_int)(jdns_session_t *s, void *app);
 
-	// debug_line:
-	//   s: session
-	//   app: user-supplied context
-	//   str: a line of debug text
-	//   return: nothing
+	/*  debug_line: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    str: a line of debug text */
+	/*    return: nothing */
 	void (*debug_line)(jdns_session_t *s, void *app, const char *str);
 
-	// udp_bind:
-	//   s: session
-	//   app: user-supplied context
-	//   addr: ip address of interface to bind to.  0 for all
-	//   port: port of interface to bind to.  0 for any
-	//   maddr: multicast address.  0 if not using multicast
-	//   return: handle (>0) of bound socket, or 0 on error
-	// note: for multicast, the following must be done:
-	//   use SO_REUSEPORT to share with other mdns programs
-	//   use IP_ADD_MEMBERSHIP to associate addr and maddr
-	//   set IP_MULTICAST_TTL to 255
+	/*  udp_bind: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    addr: ip address of interface to bind to.  0 for all */
+	/*    port: port of interface to bind to.  0 for any */
+	/*    maddr: multicast address.  0 if not using multicast */
+	/*    return: handle (>0) of bound socket, or 0 on error */
+	/*  note: for multicast, the following must be done: */
+	/*    use SO_REUSEPORT to share with other mdns programs */
+	/*    use IP_ADD_MEMBERSHIP to associate addr and maddr */
+	/*    set IP_MULTICAST_TTL to 255 */
 	int (*udp_bind)(jdns_session_t *s, void *app,
 		const jdns_address_t *addr, int port,
 		const jdns_address_t *maddr);
 
-	// udp_unbind:
-	//   s: session
-	//   app: user-supplied context
-	//   handle: handle of socket obtained with udp_bind
-	//   return: nothing
+	/*  udp_unbind: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    handle: handle of socket obtained with udp_bind */
+	/*    return: nothing */
 	void (*udp_unbind)(jdns_session_t *s, void *app, int handle);
 
-	// udp_read:
-	//   s: session
-	//   app: user-supplied context
-	//   handle: handle of socket obtained with udp_bind
-	//   addr: store ip address of sender
-	//   port: store port of sender
-	//   buf: store packet content
-	//   bufsize: value contains max size, to be changed to real size
-	//   return: 1 if packet read, 0 if none available
+	/*  udp_read: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    handle: handle of socket obtained with udp_bind */
+	/*    addr: store ip address of sender */
+	/*    port: store port of sender */
+	/*    buf: store packet content */
+	/*    bufsize: value contains max size, to be changed to real size */
+	/*    return: 1 if packet read, 0 if none available */
 	int (*udp_read)(jdns_session_t *s, void *app, int handle,
 		jdns_address_t *addr, int *port, unsigned char *buf,
 		int *bufsize);
 
-	// udp_write:
-	//   s: session
-	//   app: user-supplied context
-	//   handle: handle of socket obtained with udp_bind
-	//   addr: ip address of recipient
-	//   port: port of recipient
-	//   buf: packet content
-	//   bufsize: size of packet
-	//   return: 1 if packet taken for writing, 0 if this is a bad time
+	/*  udp_write: */
+	/*    s: session */
+	/*    app: user-supplied context */
+	/*    handle: handle of socket obtained with udp_bind */
+	/*    addr: ip address of recipient */
+	/*    port: port of recipient */
+	/*    buf: packet content */
+	/*    bufsize: size of packet */
+	/*    return: 1 if packet taken for writing, 0 if this is a bad time */
 	int (*udp_write)(jdns_session_t *s, void *app, int handle,
 		const jdns_address_t *addr, int port, unsigned char *buf,
 		int bufsize);
@@ -360,144 +360,144 @@
 
 typedef struct jdns_event
 {
-	int type;   // JDNS_EVENT
-	int id;     // query id or publish id
+	int type;   /*  JDNS_EVENT */
+	int id;     /*  query id or publish id */
 
-	// for query, this can be SUCCESS, NXDOMAIN, ERROR, or TIMEOUT
-	// for publish, this can be SUCCESS, ERROR, or CONFLICT
+	/*  for query, this can be SUCCESS, NXDOMAIN, ERROR, or TIMEOUT */
+	/*  for publish, this can be SUCCESS, ERROR, or CONFLICT */
 	int status;
 
-	// for query
+	/*  for query */
 	jdns_response_t *response;
 } jdns_event_t;
 
 void jdns_event_delete(jdns_event_t *e);
 
-// jdns_session_new:
-//   callbacks: the struct of callbacks
-//   return: newly allocated session
+/*  jdns_session_new: */
+/*    callbacks: the struct of callbacks */
+/*    return: newly allocated session */
 jdns_session_t *jdns_session_new(jdns_callbacks_t *callbacks);
 
-// jdns_session_delete:
-//   s: session to free
-//   return: nothing
+/*  jdns_session_delete: */
+/*    s: session to free */
+/*    return: nothing */
 void jdns_session_delete(jdns_session_t *s);
 
-// jdns_init_unicast:
-//   s: session
-//   addr: ip address of interface to bind to.  NULL for all
-//   port: port of interface to bind to.  0 for any
-//   return: 1 on success, 0 on failure
+/*  jdns_init_unicast: */
+/*    s: session */
+/*    addr: ip address of interface to bind to.  NULL for all */
+/*    port: port of interface to bind to.  0 for any */
+/*    return: 1 on success, 0 on failure */
 int jdns_init_unicast(jdns_session_t *s, const jdns_address_t *addr,
 	int port);
 
-// jdns_init_multicast:
-//   s: session
-//   addr: ip address of interface to bind to.  NULL for all
-//   port: port of interface to bind to.  0 for any
-//   addr: multicast address to associate with.  cannot be NULL
-//   return: 1 on success, 0 on failure
+/*  jdns_init_multicast: */
+/*    s: session */
+/*    addr: ip address of interface to bind to.  NULL for all */
+/*    port: port of interface to bind to.  0 for any */
+/*    addr: multicast address to associate with.  cannot be NULL */
+/*    return: 1 on success, 0 on failure */
 int jdns_init_multicast(jdns_session_t *s, const jdns_address_t *addr,
 	int port, const jdns_address_t *maddr);
 
-// jdns_shutdown:
-//   s: session
-//   return: nothing
+/*  jdns_shutdown: */
+/*    s: session */
+/*    return: nothing */
 void jdns_shutdown(jdns_session_t *s);
 
-// jdns_set_nameservers:
-//   s: session
-//   nslist: list of nameservers
-//   return nothing
+/*  jdns_set_nameservers: */
+/*    s: session */
+/*    nslist: list of nameservers */
+/*    return nothing */
 void jdns_set_nameservers(jdns_session_t *s,
 	const jdns_nameserverlist_t *nslist);
 
-// jdns_probe:
-//   s: session
-//   return: nothing
+/*  jdns_probe: */
+/*    s: session */
+/*    return: nothing */
 void jdns_probe(jdns_session_t *s);
 
-// jdns_query:
-//   s: session
-//   name: the name to look up
-//   rtype: the record type
-//   return: id of this operation
+/*  jdns_query: */
+/*    s: session */
+/*    name: the name to look up */
+/*    rtype: the record type */
+/*    return: id of this operation */
 int jdns_query(jdns_session_t *s, const unsigned char *name, int rtype);
 
-// jdns_cancel_query:
-//   s: session
-//   id: the operation id to cancel
-//   return: nothing
+/*  jdns_cancel_query: */
+/*    s: session */
+/*    id: the operation id to cancel */
+/*    return: nothing */
 void jdns_cancel_query(jdns_session_t *s, int id);
 
-// jdns_publish:
-//   s: session
-//   mode: JDNS_PUBLISH shared or unique
-//   rec: the record data
-//   return: id of this operation
-// note: supported record types: A, AAAA, SRV, CNAME, PTR, TXT, and HINFO.
-//   if the published type is not one of these, raw rdata must be set.
+/*  jdns_publish: */
+/*    s: session */
+/*    mode: JDNS_PUBLISH shared or unique */
+/*    rec: the record data */
+/*    return: id of this operation */
+/*  note: supported record types: A, AAAA, SRV, CNAME, PTR, TXT, and HINFO. */
+/*    if the published type is not one of these, raw rdata must be set. */
 int jdns_publish(jdns_session_t *s, int mode, const jdns_rr_t *rec);
 
-// jdns_update_publish:
-//   s: session
-//   id: the operation id to update
-//   rec: the record data
-//   return: nothing
-// note: update only works on successfully published records, and no event
-//   is generated for a successful update.
+/*  jdns_update_publish: */
+/*    s: session */
+/*    id: the operation id to update */
+/*    rec: the record data */
+/*    return: nothing */
+/*  note: update only works on successfully published records, and no event */
+/*    is generated for a successful update. */
 void jdns_update_publish(jdns_session_t *s, int id, const jdns_rr_t *rec);
 
-// jdns_cancel_publish:
-//   s: session
-//   id: the operation id to cancel
-//   return: nothing
+/*  jdns_cancel_publish: */
+/*    s: session */
+/*    id: the operation id to cancel */
+/*    return: nothing */
 void jdns_cancel_publish(jdns_session_t *s, int id);
 
-// jdns_step:
-//   s: session
-//   return: JDNS_STEP flags OR'd together
+/*  jdns_step: */
+/*    s: session */
+/*    return: JDNS_STEP flags OR'd together */
 int jdns_step(jdns_session_t *s);
 
-// jdns_next_timer:
-//   s: session
-//   return: milliseconds until timeout
+/*  jdns_next_timer: */
+/*    s: session */
+/*    return: milliseconds until timeout */
 int jdns_next_timer(jdns_session_t *s);
 
-// jdns_set_handle_readable:
-//   s: session
-//   handle: handle that is now readable
-//   return: nothing
+/*  jdns_set_handle_readable: */
+/*    s: session */
+/*    handle: handle that is now readable */
+/*    return: nothing */
 void jdns_set_handle_readable(jdns_session_t *s, int handle);
 
-// jdns_set_handle_writable:
-//   s: session
-//   handle: handle that is now writable
-//   return: nothing
+/*  jdns_set_handle_writable: */
+/*    s: session */
+/*    handle: handle that is now writable */
+/*    return: nothing */
 void jdns_set_handle_writable(jdns_session_t *s, int handle);
 
-// jdns_next_event:
-//   s: session
-//   return: newly allocated event, or zero if none are ready
+/*  jdns_next_event: */
+/*    s: session */
+/*    return: newly allocated event, or zero if none are ready */
 jdns_event_t *jdns_next_event(jdns_session_t *s);
 
-// jdns_system_dnsparams:
-//   return: newly allocated dnsparams from the system
+/*  jdns_system_dnsparams: */
+/*    return: newly allocated dnsparams from the system */
 jdns_dnsparams_t *jdns_system_dnsparams();
 
-// jdns_set_hold_ids_enabled
-//   s: session
-//   enabled: whether to enable id holding.  default is 0 (disabled)
-//   return: nothing
-// normally, when a unicast query completes or any kind of query or publish
-//   operation results in an error, the operation is automatically "canceled".
-//   when id holding is enabled, the operation still stops internally, but the
-//   id value used by that operation is "held" until the application
-//   explicitly calls jdns_cancel_query() or jdns_cancel_publish() to release
-//   it.  this allows the application to ensure there is no ambiguity when
-//   determining which operation a particular event belongs to.  it is disabled
-//   be default so as to not introduce memory leaks in existing applications,
-//   however new applications really should use it.
+/*  jdns_set_hold_ids_enabled */
+/*    s: session */
+/*    enabled: whether to enable id holding.  default is 0 (disabled) */
+/*    return: nothing */
+/*  normally, when a unicast query completes or any kind of query or publish */
+/*    operation results in an error, the operation is automatically "canceled". */
+/*    when id holding is enabled, the operation still stops internally, but the */
+/*    id value used by that operation is "held" until the application */
+/*    explicitly calls jdns_cancel_query() or jdns_cancel_publish() to release */
+/*    it.  this allows the application to ensure there is no ambiguity when */
+/*    determining which operation a particular event belongs to.  it is disabled */
+/*    be default so as to not introduce memory leaks in existing applications, */
+/*    however new applications really should use it. */
 void jdns_set_hold_ids_enabled(jdns_session_t *s, int enabled);
 
 #ifdef __cplusplus
Index: src/xmpp/xmpp-core/stream.cpp
===================================================================
--- src/xmpp/xmpp-core/stream.cpp	(revision 1355305)
+++ src/xmpp/xmpp-core/stream.cpp	(working copy)
@@ -445,6 +445,7 @@
 	if (context) {
 		return context->property("scram-salted-password-base64").toString();
 	}
+	return QString();
 }
 
 void ClientStream::setResourceBinding(bool b)
Index: src/xmpp/xmpp-core/protocol.cpp
===================================================================
--- src/xmpp/xmpp-core/protocol.cpp	(revision 1355305)
+++ src/xmpp/xmpp-core/protocol.cpp	(working copy)
@@ -1653,7 +1653,7 @@
 				r.setAttribute("id", e.attribute("id"));
 				QDomElement bind = doc.createElementNS(NS_BIND, "bind");
 				QDomElement jid = doc.createElement("jid");
-				Jid j = user + '@' + host + '/' + resource;
+				Jid j = QString(user + '@' + host + '/' + resource);
 				jid.appendChild(doc.createTextNode(j.full()));
 				bind.appendChild(jid);
 				r.appendChild(bind);
Index: src/xmpp/xmpp-im/s5b.cpp
===================================================================
--- src/xmpp/xmpp-im/s5b.cpp	(revision 1355305)
+++ src/xmpp/xmpp-im/s5b.cpp	(working copy)
@@ -40,8 +40,6 @@
 
 static const char *S5B_NS = "http://jabber.org/protocol/bytestreams";
 
-#define S5B_DEBUG
-
 namespace XMPP {
 
 static QString makeKey(const QString &sid, const Jid &requester, const Jid &target)
